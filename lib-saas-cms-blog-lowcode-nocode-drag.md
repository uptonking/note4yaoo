---
title: lib-saas-cms-blog-lowcode-nocode-drag
tags: [blog, cms, dnd, drag, lowcode]
created: 2024-04-12T12:31:48.876Z
modified: 2024-04-12T12:32:25.184Z
---

# lib-saas-cms-blog-lowcode-nocode-drag

# guide

# blogs

# blogs-architecture

## [实战，一个高扩展、可视化低代码前端，详实、完整 - 掘金 _202303](https://juejin.cn/post/7205361008272326716)

- RxEditor是一款开源企业级可视化低代码前端，目标是可以编辑所有 HTML 基础的组件。比如支持 React、VUE、小程序等，目前仅实现了 React 版
- 目标，是能够通过拖拽的方式操作基于 HTML 制作的组件，如：调整这些组件的包含关系，并设置组件属性。
- 编辑器（RxEditor）要维护一个树形模型，这个模型描述的是组件的隶属关系，以及 props。同时还能跟 dom 树交互，通过各种 dom 事件，操作组件模型树。
- 这里关键的一个点是，编辑器需要知道 dom 节点跟组件节点之间的对应关系。在不侵入组件的前提下，并且还要忽略前端库的差异，比较理想的方法是给 dom 节点赋一个特殊属性，并跟模型中组件的 id 对应，在 RxEditor 中，这个属性是rx-id，比如在dom节点中这样表示 `<div rx-id="one-uuid">`. 
- rx-id 算是设计器的基础性原理，它给设计器内核抹平了前端框架的差异
- 编辑器操作的是JSON格式的组件树，设计时，设计引擎根据这个组件树渲染画布。这个组件树是设计器的数据模型，通常会被叫做 Schema。
- 项目中的前端组件，要在两个地方渲染，一是设计引擎的画布，另一处是预览页面。这两处使用的是不同渲染引擎
- 设计形态，在设计器画布内渲染，需要提供ref或者转发rx-id，有能力跟设计引擎交互。
- 预览形态，预览引擎使用，渲染机制跟运行时渲染一样。相当于普通的前端组件。
- 设计形态的组件跟预览形态的组件，对应的是同一份schema，只是在渲染时，使用不同的组件实现。
- Material，物料的定义。一个Schema，只是用来描述一个组件，这个组件相关的配置，比如多语言信息、在工具箱中的图标、编辑规则（比如：内容类型限制）等等这些信息，需要一个配置来描述，这个就是物料
  - 一个物料的定义是一个js对象, 这里简单分享前几个版本的热加载经验
  - js 原生import可以引入远程定义的物料，但是这个方式有个明显的缺点，就是不能跨域。如果没有跨域需求，可以用这种方式。
  - webpack组件联邦，但并没有尝试过
  - src引入, 以前的版本中已经成功实现，具体做法是在编译的物料库里，把物料的定义挂载到全局window对象上，在编辑器里动态创建一个 script 元素，在load事件中，从全局window对象上拿到定义
- 设计器的画布目前使用的iframe，相当于一个应用启动了两套React，如果从设计器通过window对象，把物料传给iframe画布，react会报错。所以需要在iframe内部单独热加载物料
- 状态管理。rxjs虽然看起来不错，但是没有使用经验，暂时放弃了。mobx，个人不喜欢，与上面的设计原则“尽量减少对组件的入侵，最大程度使用已有组件资源”相悖，也只能放弃。最后，选择了Redux。 
  - 目前项目里，有三个地方用到了Redux，各自维护自己的状态树的Root节点，也就是分别维护自己的状态树
  - 设计器状态树 设计器引擎逻辑上维护一棵节点树，节点树跟带 rx-id 的 dom 节点一一对应。
  - 数据模型状态树 fieldy模块的数据模型主要用来管理页面的数据模型，预览页面、右侧属性面板都是用这个模型
  - 逻辑编排设计器状态树 这个有机会再单独成文介绍吧
- 软件架构, 软件被划分为两个比较独立的部分：
  - 设计器，用于设计页面，消费的是设计形态的组件。生成页面Schema。
  - 运行时，把设计器生成的页面Schema，渲染为正常运行的页面，消费的是预览形态的组件。 采用分层设计架构，上层依赖下层。
  - 设计器的最底层是core包，在它之上是react-core、vue-core，再往上就是shell层，比如Antd shell、Mui shell等。
  - core包是整个设计器的基础，包含了 Redux 状态树、页面互动逻辑，编辑器的各种状态等。
  - 运行时包含三个包：ComponentRender、fieldy跟minions，前者依赖后两者
- 画布的实现方式大概有三种方式，都有各自的优缺点
  - div实现方式，把设计器组件树渲染在一个div内，跟设计器没有隔离，这中实现方式比较简单，性能也好。缺点就是js上下文跟css样式没有隔离机制，被设计页面的样式不够独立。类似 position:fixed 的样式需要在画布最外层加一个隔离，比如：transform:scale(1) 。div作为画布，是模拟不了浏览器大小的，无法触发@media 查询，对响应式页面的设计并不十分友好。
  - web component沙箱方式，用 shadow dom 作为画布，把设计器组件树渲染在 shadow dom 内。这样的实现方式，性能跟div方式差不多，还可以有效隔离js上下文跟css样式。shadow dom 不能模拟浏览器大小，它的大小改变也不能触发无法触发@media 查询。
  - iframe实现方式，把设计器组件树渲染在 iframe 内，iframe会隔离js跟css，并且iframe尺寸的变化也会触发 @media 查询，是非常理想的实现方式，RxEditor 最终也锁定在了这种实现方式上。
  - iframe.src方式渲染，定义一个画布渲染组件，并配置路由，把路由地址传入iframe.src实现了样式隔离和减少入侵，就是渲染画布的时候，需要一段时间初始化React，性能上比上述方式略差

## [挑战零代码：可视化逻辑编排 - 掘金 _202307](https://juejin.cn/post/7257814347463671863)

- 逻辑编排的目的，是用最少甚至不用代码来实现软件的业务逻辑，包括前端业务逻辑跟后端业务逻辑。
- 本文前端代码基于typescript、react技术栈，后端基于golang。
- 涵盖内容：数据流驱动的逻辑编排原理，业务编排编辑器的实现，页面控件联动，前端业务逻辑与UI层的分离，子编排的复用、自定义循环等嵌入式子编排的处理、事务处理等
- 逻辑编排编辑器，顾名思义，可视化编辑器，根据物料提供的元件信息，编辑生成JSON格式的“编排描述数据”。
- 前端解析引擎，Typescript 实现的解析引擎，直接解析“编排描述数据”并执行，从而实现的软件的业务逻辑。
- 后端解析引擎，Golang 实现的解析引擎，直接解析“编排描述数据”并执行，从而实现的软件的业务逻辑

## [css-in-js、React Redux经典案例：仿钉钉审批流 - 掘金 _202308](https://juejin.cn/post/7263858443329191996)

- 只包含审批流设计部分，不包含表单的设计，表单的设计请参考作者另一个可视化前端项目rxdrag
- 这个项目非常典型，它足够小，不至于让文章太长；另外，它足够完整，涵盖了一个设计器的大部分内容，比如状态管理、物料管理、属性面板、撤销重做、画布缩放、皮肤切换、多语言管理、文件的导入导出等
- workflow-editor 是编辑器核心，未来要作为独立的npm package来发布；example 是演示如何使用workflow-editor来把审批流集成入自己的项目。
- 画布区是通过嵌套的`div`实现的，连线、箭头是通过css的border、伪类before跟after实现的
- UI虽然是树形结构，但是项目内部的数据结构可以是树形，也可以是扁平的。最后选择了树形数据结构, 因为后端是树形结构，跟div的结构一致
- 不想选mobx。因为这么小的编辑器项目，mobx的撤销、重做的工作量，要比Redux大。
- redux基于immutable的操作方式，可以保留状态快照，易于回溯，很容易就能完成撤销、重做功能
- EditorEngine。编辑器的绝大多数业务逻辑，都在这部分实现，主要功能就是操作Redux store
- 物料就是节点的定义，包括节点的图标、颜色、缺省配置等信息。把这些信息独立出来的好处，是让代码更容易扩展，方便后期添加新的节点类型。作者自己开源低代码前端RxDrag，也用了类似的设计方式
- workflow-editor对外提供两个组件：FlowEditorScope，FlowEditorCanvas。前者负责接收各种配置资源，比如物料、物料ui、多语言资源。FlowEditorCanvas是画布区，流程图的所有UI，都在这里面。通常思路，会把这两个合并为一个FlowEditor组件，外部只引用一次就可以。这样的话，集成的灵活性会丧失一些。

## [前端物料在低代码研发模式下的探索 金禅 _202312](https://jinchan.space/blog/kk06ev)

# more
