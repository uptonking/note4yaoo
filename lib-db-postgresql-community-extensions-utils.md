---
title: lib-db-postgresql-community-extensions-utils
tags: [community, extensions, postgresql, utils]
created: 2023-10-26T21:43:22.791Z
modified: 2023-10-26T21:43:43.231Z
---

# lib-db-postgresql-community-extensions-utils

# guide

# discuss-stars
- ## 

- ## 

- ## Online Schema change for PostgreSQL
- https://twitter.com/PeterZaitsev/status/1759213177538216008
  - [Revolutionizing PostgreSQL Schema Changes with `pg_osc` - Mydbops | Blog _202401](https://www.mydbops.com/blog/postgresql-schema-changes-with-pg_osc/)

- ## [PGX: Write Postgres extensions in Rust instead of C | Hacker News_202007](https://news.ycombinator.com/item?id=23821112)

# discuss-ai-pg
- ## 

- ## 

- ## 

- ## zed: Use the Postgres Context Server extension to automatically inject your Postgres table schemas into the assistant's context
- https://x.com/zeddotdev/status/1865144955812934103
- Smoking it is bad enough. Injecting it is asking for a nightmare

# discuss-pg-saas/platform
- ## 

- ## 

- ## 

- ## [Aquameta: Web development platform built in PostgreSQL | Hacker News _201910](https://news.ycombinator.com/item?id=21281042)
- I think this is an awesome idea. I really like the Smalltalk approach of not using files and instead representing the structure of a program purely in memory. I also love the idea of drawing inspiration from spreadsheets and databases instead of representing programs purely in lines of code.
  - Any long-lived executable sits in memory (notwithstanding paging, which the database server is also subject to), and such an executable is free to maintain any files it accesses in memory as well.
- I think what was being referred to is the technique of defining a program, not as source code files which are then compiled/run in an interpreter, but as an in-memory VM environment (think REPLs). The memory-based environment can then be saved to a file, similar to making a core dump.
  - This changes the structure of programs from a file/disk based structure, to the potentially richer structure of the programming environment (e.g. graphs of objects). Although it comes with disadvantages like losing the tool inter-operability of files.
- I have a hard time seeing advantages of ditching files. I like this concept, but you can have it both ways (come up with a graphical notation that you can then manipulate with graph like tools), but at the end of the day you need a source of truth, and the file metaphor (a named region of code) is hard to beat (impossible to beat?). Even databases store things as files.
- File systems are just one approach to storage. 
  - Databases can use file systems, block devices, or object-based storage (such as distributed storage systems, e.g. Ceph, Amazon S3). 
  - Traditional file systems are, by themselves, inadequate for many use case, as they don't provide things like versioning. 
  - The strength of the file system, is that much tooling already exists for it.

- I guess this isn't that dissimilar from Git, except that when you snapshot your environment, you get everything (code, IDE settings, issue tracking, and persistent data) all in the same dump.
  - if we had a way to version code that combines source, data, and issues, I'm super interested. It just needs to pipe into existing tools rather than recreating existing tools.

- Oracle have already done this, it's called Application Express[0]. I used it for my last job. In practice it was pretty good for fast prototyping and iterating on database-backed apps. It took the schema as the source of truth and would add useful interface features based on it (eg, dropdown lists derived from foreign keys, converting some check constraints to javascript validation code etc).
  - But on the downside it was essentially untestable and version control meant dumping a massive file of autogenerated PL/SQL and checking it into git. For anything more complicated than basic CRUD and reporting you'd wind up cracking the hood to directly use PL/SQL and then skin it with APEX. The tradeoff being that you lost some of the roundtrip niceties.

- Databases have been basically awful at being approachable from the command-line.
  - Let's say I have some HTML in some field in the db and want to make a change to it from the terminal. How do I do this?
  - Aquameta has a filesystem integration layer that lets you browse the database from the command line, grep database content, edit the content of a field using your preferred text editor
  - Generally just trying to ease these pain points has been a big goal of the project... still a lot to do.

- The problem with not putting business logic in an RDBMS is that you risk ending up with an application which evolves towards... implementing features already provided by the RDBMS.

- For a good overview of what power and speed you can have by "putting a web development platform entirely inside an RDBMS", check out this video called "Twitter-like App in 20 minutes with Oracle APEX"

- Is this comparable to Oracle Apex, which is a web development tool written entirely in oracle PL/SQL?
  - Used Apex when it first came out (as HTMLDB). Iâ€™ve never found anything that compared to its speed in rolling out web based forms for internal use

- reminds me of couchdb apps where you'd use document attachments to store html/public files and serve them directly from couch.

- This is actually really similar to on-premise SharePoint development; list data, content types, workflow definitions, front-end HTML, CSS, JS code are just stored in the back end database.

- Data driven applications are cool, I think I'd use Datomic over Postgres but it didn't exist 20 years ago
# discuss
- ## 

- ## 

- ## ðŸ”¥ [Dbdev â€“ A database package manager for PostgreSQL trusted language extensions | Hacker News_202304](https://news.ycombinator.com/item?id=35570758)
- 
- 
- 

- ## ðŸ”¥ [Launch HN: Hydra (YC W22) â€“ Query any database via Postgres | Hacker News_202202](https://news.ycombinator.com/item?id=30442718)
- Hydra is a Postgres extension that intelligently routes queries through Postgres to other databases. 
  - Engineers query regular Postgres, and Hydra extends a Postgres-compliant SQL layer to non-relational, columnar, and graph DBs. 
  - It currently works with Postgres and Snowflake, and we have a roadmap to support MongoDB, Google BigQuery, and ClickHouse.
- 
- 
- 
