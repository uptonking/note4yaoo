---
title: lib-editor-block-affine-community
tags: [affine, block-editor, collaboration, community]
created: 2023-02-03T16:06:45.939Z
modified: 2023-02-03T16:12:13.346Z
---

# lib-editor-block-affine-community

# guide

# discuss
- ## 

- ## 

- ## 

- ## I would say that BlockSuite works very differently from traditional rich text editors_202301
- https://discord.com/channels/959027316334407691/1006208074316521573/1062287261724577822
- For rich text editing, multiple different nodes in the BlockSuite block tree can be connected to different rich text editing components, thus we are modeling rich text content as multiple UI components instead of a single UI container, eliminating the use of the dangerous monolith contenteditale - So for a page with hundreds of paragraphs, we can have hundreds of quill instances!
- With this design, the rich text components in BlockSuite will only contain **flat text content**, this greatly simplifies the architecture of managing rich text. 
  - That's also pretty much why we are using Quill temporally -  because its data structure is exactly modeled in this flat way, and its Delta format is natively supported by Yjs, bringing us a pretty stable experience. 
  - Based on this approach, we are actually only using a tiny feature subset of Quill, and it's also in our plan to build an alternative from the ground up.
- The thing that fascinates me about jumping out of the monolith contenteditable is to blur the boundary between the “editor” and “non-editor” part, making the tech stack of your collaborative app as regular as TodoMVC. 
- Note that this pattern requires a breakthrough in state management - for having intuitive undo/redo, we need to reconcile the state between different rich text components. Beforehand, I didn’t see any store library that supports rich text as its primitive, and that’s why we built our general-purpose store on top of Yjs since this’s what CRDT is extremely good at. Think about Redux-like time traveling that comes with zero-cost, character-wise incremental updates!
- With such a store, the view components of your blocks only need to subscribe to model updates
- This is a standard best practice, and although we are using the Lit framework (mainly for future WebComponent-based extensibility prepared for AFFiNE), I believe there is no rocket science or black magic here, and that’s how we build our AFFiNE editor just like developing yet another Dashboard app. 
- We haven’t started publicly endorsing this pattern because we are working hard on making the new AFFiNE stable and finding some best practices here. 

- This is also kind of how Notion is built if I'm not mistaken... It allows them to save each block as a row in the database as well, thus avoiding having to store a giant document with all the deltas generated by Yjs

- multiple-contentEditables design simplifies your initial implementation but prevents text selection of multiple blocks. Be careful accepting this limitation to begin with, because adding a wrapping ContentEditable later may be tricky.
