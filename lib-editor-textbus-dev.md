---
title: lib-editor-textbus-dev
tags: [text-editor, textbus]
created: 2021-10-07T14:50:16.532Z
modified: 2021-10-07T14:50:51.512Z
---

# lib-editor-textbus-dev

# guide

- features
  - 从contenteditable到完全自定义光标
  - 抽象选区
  - 自实现虚拟DOM
  - 高性能渲染器
  - collab using yjs
  - 可扩展的架构，设计了Plugin、Module、
  - 创新的组件化系统

- cons
  - 示例不是 block-editor
  - 框架层使用自研依赖注入di
# not-yet

# faq

- 🤔 既然使用了虚拟渲染，是不是可以不用vdom
  - 参考typewriter，在计算出窗口内的最少元素后，渲染仍然可以用vdom渲染

- Textbus的数据结构是什么样的
  - 一个组件树对象，通过调用任意组件的 toJSON 方法，可以获取当前组件的 JSON 格式对象。

- 光标不见了
  - 大部分情况是因为你的浏览器安装了划词翻译插件，由于 Textbus 默认情况下是采用自绘光标，会导致和划词翻译插件产生冲突。
  - 你可以在编辑器配置项里配置 `useContentEditable: true` 通过开启原生光标规避此问题。

- 可以用在 Vue/React 框架里吗
  - Textbus 不依赖作何前端框架，可以和任意技术栈集成。

- 怎么操作DOM
  - Textbus 是数据驱动的，大多数情况下，你不需要操作 DOM，只需要更改组件或插槽的数据，Textbus 会根据数据变化，自动更新 DOM。
  - 如果确实需要操作 DOM，你可以通过给虚拟 DOM 节点添加 Ref 对象，并在渲染完成后，通过 ref.current 拿到 DOM 对象。
  - 注意，Textbus 并不会关注 DOM 数据的变化，所以，你操作 DOM 的数据，并不会同步到 Textbus 的数据模型。
# changelog

## v3.0.0_20221127

- 渲染模式支持3种，分别为输出、只读、编辑，v2缺少只读
- 调整了 render 函数的参数顺序
- slotRender 除了把子节点传入外，回调函数返回的虚拟 DOM 也可以为任意结构了。
- 由于 3.* 版本中，插槽也可以有复杂结构。在 Textbus 2.* 中，组件加载器识别插槽内容由 slotParser 的第二个参数指定插槽的根节点。

- 在 Textbus 2.* 中，我们可以任意创建 DOM 元素，并插入到文档中，Textbus 的渲染器在 diff 过程中，会忽略这些动态插入的 DOM 节点。
  - 在 3.* 中，这些“意外”插入的 DOM 节点，会被认为是脏的，并从文档中删除。

- 格式
  - 在 2.* 中，我们可以通过配置 Formatter 的 type 属性，标识一个格式是块级还是行内。
  - 在 3.* 中，块级格式，块级格式改为用属性（Attribute）实现。并删除了原 2.* 中格式中的 type 属性和渲染优先级配置。

- 在 3.* 中，转换器的功能合并到了注册表。
  - 在 2.* core 模块中，Textbus 使用注册表（Registry）和转换器（Translator）来分别管理，组件及格式的注册和创建。

## v2.0.0_20220818

- 重新设计了数据模型，可根据用户的操作生成特定的底层原子命令，这让细粒度的历史记录和文档协同成为可能
- 核心架构脱离了具体平台，让 TextBus 的能力不仅限于在 PC 端，通过编写特定的中间层，可以方便的在移动端，甚至小程序上实现丰富的富文本能力
- 重新设计了组件系统，去掉了大家难以理解的装饰器，改为用类似 vue 的 setup 形式开发组件，并提供了一系列的 hooks 供大家定制交互行为
- 重写了渲染层，现在 TextBus 2.0 大多数情况下更新视图仅需要 1ms 时间，比 1.0 性能更好
# docs

## [架构设计](https://textbus.io/docs/advance/)

- 得益于 Textbus 高效的渲染器（Renderer），对于超长文档，或者复杂组件，你总是能得到几乎 1ms 内的视图更新效率，同时生成最干净的富文本内容。
- Textbus 还可以实现在不同平台上的富文本开发能力。通过桥接，可以很方便的桥接到小程序、移动端等不同的平台。事实上，Textbus 的内核是和 DOM 无关的富文本抽象。
- Textbus 采用分层架构设计。目前有三个模块
- core核心模块：提供了 Textbus 文档的基本数据模型、操作、渲染，以及状态查询、选区、数据转换、历史记录等；
- browser浏览器支持模块：提供了 PC 端编辑器的视图层，如选区、HTML 解析、光标及文本输入等；
- editor：Textbus 官方实现的 PC 端富文本编辑器，提供了大多数富文本所需的功能。
# discuss

## [为什么要造 TextBus](https://www.zhihu.com/question/366666295/answer/977653172)

- 市面上比较成熟的方案的问题
  1. 现在所有的富文本输出都太脏了，做过富文本的都知道，要让富文本不脏，是有多难。
  2. 很多对表格支持不友好，如框选操作。
  3. 很多项目都很老，设计已落后，包括对现在的前端工具链支持不好或不支持。
  4. 部分项目对其它库或框架有依赖，限制了应用场景。
  5. 扩展比较难，整体抽象程度不够，导致新增功能需要面对的复杂度高，一般开发者很难参与。
  6. 很多富文本太多魔术字符串，如配置 toolbar，吐槽一下，基本都是魔术字符串，对于没看过文档的人，根本不知道要怎么配置。

- 目前 TextBus 都解决了
  1. TBus 的输出结果很干净，没有冗余标签和垃圾数据。
  2. TBus 支持表格框选操作。
  3. TBus 采用 Typescript 作为开发语言，对 IDE 和 前端工具链支持友好。
  4. TBus 开箱即用，不限制框架和库。
  5. TBus 核心功能都是以插件形式存在的，且有着较高的抽象，只需要操作数据，不需要关心标签插在哪里，不需要关心 DOM 结构，不需要关心选区复位。
  6. TBus 配置没有魔术字符串，完全基于接口（interface) 加枚举量，因此对 treeshake 非常友好。

- 输入框是用隐藏textarea实现的？
  - 是的
