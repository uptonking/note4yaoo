---
title: cli-bash-shell
tags: [cli, lang-bash, shell]
created: 2024-01-16T11:58:24.868Z
modified: 2024-02-04T19:53:29.532Z
---

# cli-bash-shell

# guide

# Bash è„šæœ¬æ•™ç¨‹
- https://wangdoc.com/bash/
  - https://wangdoc.com/bash/condition
  - https://github.com/wangdoc/bash-tutorial
  - æœ¬æ•™ç¨‹ä»‹ç» Linux å‘½ä»¤è¡Œ Bash çš„åŸºæœ¬ç”¨æ³•å’Œè„šæœ¬ç¼–ç¨‹

- Bash å˜é‡ååŒºåˆ†å¤§å°å†™ï¼ŒHOMEå’Œhomeæ˜¯ä¸¤ä¸ªä¸åŒçš„å˜é‡ã€‚
- Bash æ²¡æœ‰æ•°æ®ç±»åž‹çš„æ¦‚å¿µï¼Œæ‰€æœ‰çš„å˜é‡å€¼éƒ½æ˜¯å­—ç¬¦ä¸²ã€‚

- Bash å…è®¸å­—ç¬¦ä¸²æ”¾åœ¨å•å¼•å·æˆ–åŒå¼•å·ä¹‹ä¸­ï¼ŒåŠ ä»¥å¼•ç”¨ã€‚
  - å•å¼•å·ç”¨äºŽä¿ç•™å­—ç¬¦çš„å­—é¢å«ä¹‰ï¼Œå„ç§ç‰¹æ®Šå­—ç¬¦åœ¨å•å¼•å·é‡Œé¢ï¼Œéƒ½ä¼šå˜ä¸ºæ™®é€šå­—ç¬¦ï¼Œæ¯”å¦‚æ˜Ÿå·ï¼ˆ*ï¼‰ã€ç¾Žå…ƒç¬¦å·ï¼ˆ$ï¼‰ã€åæ–œæ ï¼ˆ\ï¼‰ç­‰
  - åŒå¼•å·æ¯”å•å¼•å·å®½æ¾ï¼Œå¤§éƒ¨åˆ†ç‰¹æ®Šå­—ç¬¦åœ¨åŒå¼•å·é‡Œé¢ï¼Œéƒ½ä¼šå¤±åŽ»ç‰¹æ®Šå«ä¹‰ï¼Œå˜æˆæ™®é€šå­—ç¬¦ã€‚

- echo
  - echo "$a" å¯ä»¥æ‰“å°å˜é‡å€¼

- `$?`ä¸ºä¸Šä¸€ä¸ªå‘½ä»¤çš„é€€å‡ºç ï¼Œç”¨æ¥åˆ¤æ–­ä¸Šä¸€ä¸ªå‘½ä»¤æ˜¯å¦æ‰§è¡ŒæˆåŠŸã€‚è¿”å›žå€¼æ˜¯0ï¼Œè¡¨ç¤ºä¸Šä¸€ä¸ªå‘½ä»¤æ‰§è¡ŒæˆåŠŸï¼›å¦‚æžœä¸æ˜¯é›¶ï¼Œè¡¨ç¤ºä¸Šä¸€ä¸ªå‘½ä»¤æ‰§è¡Œå¤±è´¥

- check file exists in bash, -e vs -f
  - -e: Returns true if the file or directory exists, regardless of its type (regular file, directory, symbolic link, etc.)
  - -f: Returns true only if the file is a regular file (not a directory, symbolic link, etc.).

- Bashæä¾›å››ä¸ªç‰¹æ®Šè¯­æ³•ï¼Œè·Ÿå˜é‡çš„é»˜è®¤å€¼æœ‰å…³ï¼Œç›®çš„æ˜¯ä¿è¯å˜é‡ä¸ä¸ºç©ºã€‚

```shell
# å˜é‡var1å£°æ˜Ž, ç­‰å·ä¸¤è¾¹ä¸èƒ½æœ‰ç©ºæ ¼, å˜é‡å¯ä»¥é‡å¤èµ‹å€¼; è¯»å–å˜é‡ç”¨$var1
variable=value
# å¦‚æžœå˜é‡çš„å€¼åŒ…å«ç©ºæ ¼ï¼Œåˆ™å¿…é¡»å°†å€¼æ”¾åœ¨å¼•å·ä¸­ã€‚
var1="hello world"
# è¯»å–å˜é‡çš„æ—¶å€™ï¼Œå˜é‡åä¹Ÿå¯ä»¥ä½¿ç”¨èŠ±æ‹¬å·{}åŒ…å›´ï¼Œæ¯”å¦‚$aä¹Ÿå¯ä»¥å†™æˆ${a}ã€‚

# å¦‚æžœå˜é‡varnameå­˜åœ¨ä¸”ä¸ä¸ºç©ºï¼Œåˆ™è¿”å›žå®ƒçš„å€¼ï¼Œå¦åˆ™å°†å®ƒè®¾ä¸ºwordï¼Œå¹¶ä¸”è¿”å›žwordã€‚
# å®ƒçš„ç›®çš„æ˜¯è®¾ç½®å˜é‡çš„é»˜è®¤å€¼ã€‚${count:=0}è¡¨ç¤ºå˜é‡countä¸å­˜åœ¨æ—¶è¿”å›ž0ï¼Œä¸”å°†countè®¾ä¸º0ã€‚
${varname:=word}

# å¦‚æžœå˜é‡varnameå­˜åœ¨ä¸”ä¸ä¸ºç©ºï¼Œåˆ™è¿”å›žå®ƒçš„å€¼ï¼Œå¦åˆ™è¿”å›žword
# å®ƒçš„ç›®çš„æ˜¯è¿”å›žä¸€ä¸ªé»˜è®¤å€¼
${varname:-word}

# å¦‚æžœå˜é‡åå­˜åœ¨ä¸”ä¸ä¸ºç©ºï¼Œåˆ™è¿”å›žwordï¼Œå¦åˆ™è¿”å›žç©ºå€¼ã€‚
# å®ƒçš„ç›®çš„æ˜¯æµ‹è¯•å˜é‡æ˜¯å¦å­˜åœ¨
${varname:+word}

# å¦‚æžœå˜é‡varnameå­˜åœ¨ä¸”ä¸ä¸ºç©ºï¼Œåˆ™è¿”å›žå®ƒçš„å€¼ï¼Œå¦åˆ™æ‰“å°å‡ºvarname: messageï¼Œå¹¶ä¸­æ–­è„šæœ¬çš„æ‰§è¡Œ
# å®ƒçš„ç›®çš„æ˜¯é˜²æ­¢å˜é‡æœªå®šä¹‰ï¼Œæœªå®šä¹‰æ—¶å°±ä¸­æ–­æ‰§è¡Œï¼ŒæŠ›å‡ºé”™è¯¯
${varname:?message}

# if
# [ -n string ]ï¼šå¦‚æžœå­—ç¬¦ä¸²stringçš„é•¿åº¦å¤§äºŽé›¶ï¼Œåˆ™åˆ¤æ–­ä¸ºçœŸã€‚
# [ -z string ]ï¼šå¦‚æžœå­—ç¬¦ä¸²stringçš„é•¿åº¦ä¸ºé›¶ï¼Œåˆ™åˆ¤æ–­ä¸ºçœŸã€‚
# testå‘½ä»¤å†…éƒ¨çš„>å’Œ<ï¼Œå¿…é¡»ç”¨å¼•å·å¼•èµ·æ¥ï¼ˆæˆ–è€…æ˜¯ç”¨åæ–œæ è½¬ä¹‰ï¼‰ã€‚å¦åˆ™ï¼Œå®ƒä»¬ä¼šè¢« shell è§£é‡Šä¸ºé‡å®šå‘æ“ä½œç¬¦ã€‚
# [ integer1 -eq integer2 ]ï¼šå¦‚æžœinteger1ç­‰äºŽinteger2ï¼Œåˆ™ä¸ºtrueã€‚
# [ integer1 -ne inte ger2 ]ï¼šå¦‚æžœinteger1ä¸ç­‰äºŽinteger2ï¼Œåˆ™ä¸ºtrueã€‚
# [ -e file ]ï¼šå¦‚æžœ file å­˜åœ¨ï¼Œåˆ™ä¸ºtrueã€‚
# [ -d file ]ï¼šå¦‚æžœ file å­˜åœ¨å¹¶ä¸”æ˜¯ä¸€ä¸ªç›®å½•ï¼Œåˆ™ä¸ºtrueã€‚

```

# blogs-shell
- [ä¸€ç¯‡æ•™ä¼šä½ å†™90%çš„shellè„šæœ¬ - çŸ¥ä¹Ž](https://zhuanlan.zhihu.com/p/264346586)
# makefile ðŸ§°
- A simple makefile consists of â€œrulesâ€ with the following shape:
  - A target is usually the name of a file that is generated by a program. A target can also be the name of an action to carry out, such as â€˜cleanâ€™ (see Phony Targets).
  - A prerequisite is a file that is used as input to create the target. 
  - A recipe is an action that make carries out. A recipe may have more than one command

```makefile
target... : prerequisites/dependent ...
          recipe/command
          ......
          

# ç¬¬ä¸€ä¸ªæ˜¯make helpçš„æ³¨é‡Š documentation comment
create-env-files: ## Copy the dist env files to env files
create-env-files: \
	env.d/development/common \
	env.d/development/postgresql \
	env.d/development/kc_postgresql
.PHONY: create-env-files
```

- å½“ç›´æŽ¥è¿è¡Œmakeå‘½ä»¤ï¼ŒåŽé¢ä¸æŽ¥targetå‚æ•°æ—¶ï¼Œé»˜è®¤ä¼šç”ŸæˆMakefileä¸­çš„ç¬¬ä¸€ä¸ªç›®æ ‡ã€‚å¦‚æžœè¦ç”ŸæˆæŒ‡å®šç›®æ ‡ï¼Œéœ€è¦åœ¨makeå‘½ä»¤åŽé¢æŽ¥targetåç§°ã€‚

- `$(MAKE)` is valid in a Makefile
  - MAKE is a special variable in Make that refers to the make command itself. 

- 
- 
- 

- The order of rules is not significant, except for determining the default goal
  - The default goal is the first target of the first rule
  - There are two exceptions: a target starting with a period is not a default unless it also contains one or more slashes, â€˜/â€™; and, a target that defines a pattern rule has no effect on the default goal.

## [Makefile å…‰é€Ÿå…¥é—¨](https://siyuanblog.cn/archives/makefile)

- Makefile å°±æ˜¯ç®€åŒ–æˆ‘ä»¬æ•²å‘½ä»¤çš„è¿‡ç¨‹ã€‚
- Makefile å®žé™…ä¸Šå°±æ˜¯ä¸€ä¸ªæè¿°å‘½ä»¤æ‰§è¡Œè¿‡ç¨‹çš„æ–‡æœ¬æ–‡ä»¶ï¼Œå°±æ˜¯æŸç§æ„ä¹‰ä¸Šçš„ shell è„šæœ¬ï¼Œç”±å‡ ä¸ªéƒ¨åˆ†æž„æˆï¼š
  - target å°±æ˜¯è¦å®Œæˆå‘½ä»¤çš„åç§°
- makefile ä¸­å¯ä»¥å®šä¹‰è‡ªå·±çš„å˜é‡ï¼Œä»¥å®žçŽ°æ›´æ–¹ä¾¿çš„ç¼–å†™ï¼Œå˜é‡åé€šå¸¸ç”¨å…¨å¤§å†™æ¥è¡¨ç¤º
  - å˜é‡å®šä¹‰çš„ = å’Œ := æ˜¯æœ‰ä¸€å®šåŒºåˆ«çš„ï¼Œ:= çš„å€¼åœ¨èµ‹å€¼æ—¶å°±ä¼šç¡®å®šï¼Œè€Œ = æ˜¯åœ¨ä½¿ç”¨æ—¶æ‰ç¡®å®šã€‚
- åœ¨ makefile ä¸­ % è¡¨ç¤ºé€šé…ç¬¦ï¼ŒåŒ¹é…ä»»æ„å­—ç¬¦ä¸²

- æž„å»ºä¸€ä¸ªè¿‡ç¨‹å¯èƒ½æœ‰å¤šæ¡å‘½ä»¤ï¼Œå¦‚æžœç›´æŽ¥æ¢è¡Œï¼Œå‘½ä»¤æ˜¯åœ¨ä¸åŒçš„ shell ä¸Šæ‰§è¡Œçš„ï¼Œä¹Ÿå°±æ˜¯å‘½ä»¤ä¹‹é—´ä¸ä¼šç›¸äº’å½±å“
  - å¦‚æžœè¦è®©å¤šæ¡å‘½ä»¤åœ¨ä¸€ä¸ª shell ä¸­æ‰§è¡Œï¼Œå¯ä»¥ä½¿ç”¨ \ æˆ– ; 

## [makefileå¿«é€Ÿå…¥é—¨ - å†·è±ª - åšå®¢å›­](https://www.cnblogs.com/learnhow/p/15863951.html)

- ä¸€ä¸ªmakefileæ–‡ä»¶ä¸èƒ½å‡ºçŽ°é‡åçš„ç›®æ ‡åï¼Œä¸”å½“ä½ æ‰§è¡Œmakeçš„æ—¶å€™ï¼Œå®ƒä¼šé»˜è®¤æ‰§è¡Œç¬¬ä¸€æ¡ç¼–è¯‘ç‰‡æ®µï¼Œå¦‚æžœç¬¬ä¸€æ¡ç¼–è¯‘ç‰‡æ®µå¹¶æ²¡æœ‰å…¶ä»–ä¾èµ–ï¼Œmakeä¸ä¼šç»§ç»­å‘ä¸‹æ‰§è¡Œ
  - åœ¨æ£€æŸ¥ä¾èµ–å…³ç³»æ—¶ï¼ŒåŒæ—¶ä¼šæ£€æŸ¥ç›®æ ‡ä¸Žæºæ–‡ä»¶çš„æ—¶é—´æˆ³ï¼Œå½“æºæ–‡ä»¶æ—¶é—´æˆ³æ›´æ–°æ—¶ï¼Œmakeä¼šæ›´æ–°ä¾èµ–å®ƒçš„é“¾è·¯ä¸Šæ‰€æœ‰ç›®å½•ã€‚

- makefileè¿˜å¯ä»¥é€šè¿‡includeçš„æ–¹å¼åŒ…å«å…¶å®ƒmakefileæ–‡ä»¶ï¼Œå› æ­¤æˆ‘ä»¬ä¹Ÿå¯ä»¥å°†å…¬å…±çš„éƒ¨åˆ†å†™åˆ°ä¸€èµ·ã€‚
- åœ¨makefileé‡Œï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥ç¼–å†™æˆ–è°ƒç”¨shellè„šæœ¬ã€‚

- makefileä¹Ÿæœ‰é¢„å®šä¹‰çš„å˜é‡ã€‚å¸¸è§çš„æœ‰ï¼š
  - RM: åˆ é™¤ç¨‹åºï¼Œé»˜è®¤å€¼ä¸ºrm -f
  - $@: ç›®æ ‡æ–‡ä»¶çš„å®Œæ•´åç§°
  - $<: ç¬¬ä¸€ä¸ªä¾èµ–æ–‡ä»¶çš„åç§°
  - $+: æ‰€æœ‰çš„ä¾èµ–æ–‡ä»¶ï¼Œä»¥ç©ºæ ¼åˆ†å¼€ï¼Œå¹¶ä»¥å‡ºçŽ°çš„å…ˆåŽé¡ºåºï¼Œå¯èƒ½åŒ…å«é‡å¤çš„ä¾èµ–æ–‡ä»¶
  - $^: æ‰€æœ‰ä¸é‡å¤çš„ä¾èµ–æ–‡ä»¶ï¼Œä»¥ç©ºæ ¼åˆ†å¼€
  - CURDIR: makefileçš„å½“å‰è·¯å¾„

- wildcard: é€šé…ç¬¦å‡½æ•°ï¼Œè¡¨ç¤ºé€šé…æŸè·¯å¾„ä¸‹çš„æ‰€æœ‰æ–‡ä»¶ï¼Œé€šå¸¸æˆ‘ä»¬æ˜¯å°†æ‰€æœ‰*.cppæˆ–*.hæ–‡ä»¶é€‰æ‹©å‡ºæ¥å•ç‹¬å¤„ç†
- notdir: èŽ·å–åˆ°è·¯å¾„çš„æœ€åŽä¸€æ®µæ–‡ä»¶å
- strip: åŽ»æŽ‰å­—ç¬¦ä¸²å‰åŽçš„ç©ºæ ¼
- shell: ç”¨äºŽåœ¨makefileä¸­æ‰§è¡Œshellè„šæœ¬
- patsubst ç”¨äºŽè¿›è¡Œæ¨¡å¼æ›¿æ¢ï¼Œå…¶å½¢å¼ä¸ºï¼š$(patsubst pattern, replacement, text)ã€‚

- A phony target is one that is not really the name of a file; rather it is just a name for a recipe to be executed when you make an explicit request. 
  - There are two reasons to use a phony target: to avoid a conflict with a file of the same name, and to improve performance.
  - make cleanå¹¶ä¸æ˜¯ä¸ºäº†ç”Ÿæˆä¸€ä¸ªåç§°ä¸ºcleançš„æ–‡ä»¶ï¼Œä¸ºäº†é˜²æ­¢æ–‡ä»¶åŒåï¼Œå¯ä»¥ç”¨. PHONYæ¥å£°æ˜Žä¼ªç›®æ ‡ã€‚

- [[æ•™ç¨‹]ä»Žé›¶å¼€å§‹å¿«é€Ÿç¼–å†™Makefile - çŸ¥ä¹Ž](https://zhuanlan.zhihu.com/p/430029724)
- Makefileä¸­çš„ç­‰å·æœ‰4ç§ï¼Œ"="ï¼Œ":="ï¼Œ"?="ï¼Œ"+="ã€‚
  - "?="è¡¨ç¤ºï¼Œå¦‚æžœå·¦è¾¹çš„å˜é‡æ²¡æœ‰è¢«èµ‹å€¼ï¼Œé‚£ä¹ˆå°†ç­‰å·å³è¾¹çš„å€¼èµ‹ç»™å·¦è¾¹çš„å˜é‡ï¼›å¦‚æžœVAR_Aè¢«èµ‹è¿‡å€¼äº†ï¼ŒVAR_Aä¸­çš„å€¼å°†ä¿æŒåŽŸæ¥çš„å€¼ä¸å˜
  - "+="è¡¨ç¤ºå°†ç­‰å·å³è¾¹çš„å€¼è¿½åŠ åˆ°å·¦è¾¹å˜é‡ä¸­ï¼Œç±»ä¼¼äºŽCè¯­è¨€ä¸­çš„strcatå‡½æ•°
  - ":="ç†è§£ä¸º"å€¼ä¼ é€’"ã€‚
  - = å…è®¸å˜é‡çš„åµŒå¥—ä½¿ç”¨ `var_c = ${var_${var_a}}`

- Makefileçš„æ‰§è¡Œæ˜¯å—shellçŽ¯å¢ƒå˜é‡å½±å“çš„ï¼ŒshellçŽ¯å¢ƒå˜é‡ä¼šç›´æŽ¥ä¼ é€’åˆ°Makefileçš„æ‰§è¡Œè¿‡ç¨‹ä¸­ã€‚
  - å¯ä»¥åœ¨æ‰§è¡Œmakeå‘½ä»¤æ—¶ä¸ºä¼ é€’çŽ¯å¢ƒå˜é‡çš„å€¼ï¼Œå¦‚æžœæ‰§è¡Œ"make VAR_A=maybe"å‘½ä»¤ï¼Œé‚£ä¹ˆæ‰§è¡Œè¿‡ç¨‹ä¸­VAR_Aæ˜¯maybe

- åœ¨æ‰§è¡Œmakeå‘½ä»¤æ—¶ï¼Œä¼šæ‰“å°Makefileé‡Œé¢æ‰§è¡Œçš„commandï¼Œå¯ä»¥é€šè¿‡åœ¨commandå‰åŠ ä¸Š `@` æ¥å–æ¶ˆæ‰“å°commandã€‚

- æ‰§è¡Œè¿‡ç¨‹ä¸­ä¹Ÿå¯èƒ½å‡ºçŽ°é”™è¯¯ï¼Œ ä¸€èˆ¬å‡ºçŽ°é”™è¯¯åŽï¼Œmakeå‘½ä»¤ä¼šç«‹å³é€€å‡ºï¼Œåœæ­¢ç¼–è¯‘ã€‚å¦‚æžœæƒ³è¦å¿½ç•¥æ‰§è¡Œè¿‡ç¨‹ä¸­çš„é”™è¯¯ï¼Œå¯ä»¥åœ¨commandå‰åŠ ä¸Š `-` æ¥å¿½ç•¥è¿™æ¡å‘½ä»¤çš„æ‰§è¡Œé”™è¯¯ã€‚

- sincludeåœ¨æ‰¾ä¸åˆ°æ–‡ä»¶æ—¶ï¼Œå¹¶ä¸ä¼šæŠ¥é”™ï¼Œä¼šç›´æŽ¥è·³è¿‡ã€‚åˆ©ç”¨è¿™ä¸ªæœºåˆ¶ï¼Œå¯ä»¥æ›´æ–°ç›®æ ‡æ–‡ä»¶çš„ä¾èµ–å…³ç³»ã€‚
# tips
- ## [Why does the less-than sign not work as a replacement for cat in bash? - Unix & Linux Stack Exchange](https://unix.stackexchange.com/questions/106039/why-does-the-less-than-sign-not-work-as-a-replacement-for-cat-in-bash)
  - The less than and symbol (<) is opening the file up and attaching it to the standard input device handle of some application/program. But you haven't given the shell any application to attach the input to.
- the `<file` can be on either side of the command
  - `<file grep foo`; 
  - `while read line; do echo "$line"; done < file `; 

- `some-cmd < somefile` or `< somefile some-cmd`

- ## [When are square brackets required in a Bash if statement? - Stack Overflow](https://stackoverflow.com/questions/8934012/when-are-square-brackets-required-in-a-bash-if-statement)
  - The square brackets are a synonym for the `test` command
  - `test` is a command, which takes an expression and evaluates it

- ## [if statement - Are double square brackets [[ ]] preferable over single square brackets [ ] in Bash? - Stack Overflow](https://stackoverflow.com/questions/669452/are-double-square-brackets-preferable-over-single-square-brackets-in-b)
  - [[ has fewer surprises and is generally safer to use. 
  - But it is not portable - POSIX doesn't specify what it does and only some shells support it 
  - If you use [[ ]] you lose portability

- [Bash operators: "!" vs "-z" - Stack Overflow](https://stackoverflow.com/questions/51440450/bash-operators-vs-z)
  - -z STRING: returns true if the length of STRING is zero.
  - ! EXPRESSION: returns true of EXPRESSION is false
# more

# discuss-shell

- ## 

- ## 

- ## ðŸ†š [ Why use make over a shell script? - Stack Overflow](https://stackoverflow.com/questions/3798562/why-use-make-over-a-shell-script)
- The general idea is that make supports (reasonably) minimal rebuilds -- i.e., you tell it what parts of your program depend on what other parts. When you update some part of the program, it only rebuilds the parts that depend on that. 
  - While you could do this with a shell script, it would be a lot more work (explicitly checking the last-modified dates on all the files, etc.)
  - I should probably also add that there are quite a few alternatives to make that have at least broadly similar capabilities. Especially in cases where only a few files in a large project are being rebuilt, some of them (e.g., Ninja) are often considerably faster than make.

- There are various things make does that are hard to do with shell scripts
  - checks to see what is out of date, so as to build only what it needs to build
  - It performs a topological sort or some other sort of tree analysis that determines what depends on what and what order to build the out-of-date things such that every prerequisite is built before every dependency, and only built once.
  - It contains an inference engine to process rules, patterns, and dates
  - It has a macro processor.

- Make is a declarative(-ish) parallel programming language.

- [Makefiles vs. Bash Scripts : r/devops _202211](https://www.reddit.com/r/devops/comments/z1eegq/makefiles_vs_bash_scripts/)
- All my Makefiles start with: help target, Tasks starting with `--` are hidden.

- The problem with embedding bash in Makefiles is the escaping. Every line that is not a target must begin with a tab, and dollar signs to be interpreted in the shell, script have to be double dollar signs. And there are times when you need backslashes another crap like that.

- it is better practice (and less frustrating) to define your functionality in bash files and use those in the Makefile, rather than embedding them in the make file directly. That approach also lets you write tests for your build scripts, using something like bats.

- ## [curl vs wget](https://daniel.haxx.se/docs/curl-vs-wget.html)
- similarities
  - both are command line tools that can download contents from FTP, HTTP(S)
  - both support HTTP cookies

- `curl` is powered by `libcurl` - a cross-platform library with a stable API that can be used by each and everyone. (major difference)
  - curl is MIT licensed. Wget is GPL v3.
  - pipes: curl works more like the traditional Unix cat command, it sends more stuff to stdout, and reads more from stdin in a "everything is a pipe" manner. Wget is more like cp, using the same analogue.
  - More protocols: curl supports FTP(S), GOPHER(S), HTTP(S), SCP, SFTP, TFTP, TELNET, DICT, LDAP(S), MQTT, FILE, POP3(S), IMAP(S), SMB(S), SMTP(S), RTMP, RTSP and WS(S). Wget only supports HTTP(S) and FTP.
  - curl supports HTTP/0.9, HTTP/1.0, HTTP/1.1, HTTP/2 and HTTP/3 to the server and HTTP/1 and HTTP/2 to proxies. wget supports 1.0 and 1.1 and only HTTP/1 to proxies.
  - More SSL libraries and SSL support: curl can be built with one out of twelve (12!) different SSL/TLS libraries, and it offers more control and wider support for protocol details.
  - HTTP auth: curl supports more HTTP authentication methods, especially over HTTP proxies: Basic, Digest, NTLM, Negotiate and AWS v4 signatures.
  - SOCKS: curl supports SOCKS4 and SOCKS5 for proxy access. With local or proxy based name resolving.
  - curl supports HTTPS proxy, that is HTTPS to the proxy. wget does not.
  - Bidirectional: curl offers upload and sending capabilities. Wget only offers plain HTTP POST support.
  - HTTP multipart/form-data sending, which allows users to do HTTP "upload" and in general emulate browsers and do HTTP automation to a wider extent.
  - curl supports gzip, brotli, zstd and deflate Content-Encoding and does automatic decompression.
  - curl can do many transfers in parallel (-Z). wget only does serial.
  - Much more developer activity. 
  - curl comes pre-installed on macOS and Windows 10. Wget does not.

- `wget` is command line only. There's no library.
  - Recursive!: Wget's major strong side compared to curl is its ability to download recursively, or even just download everything that is referred to from a remote resource, be it a HTML page or a FTP directory listing.
  - Wget is GPL v3. curl is MIT licensed.
  - GNU: Wget is part of the GNU project and all copyrights are assigned to FSF. The curl project is entirely stand-alone and independent with no organization parenting at all with almost all copyrights owned by Daniel.
  - Wget requires no extra options to simply download a remote URL to a local file, while curl requires `-o or -O`.
  - Wget supports only GnuTLS or OpenSSL for SSL/TLS support.
  - Wget has no SOCKS support.
  - Wget enables more features by default: cookies, redirect-following, time stamping from the remote resource etc. With curl most of those features need to be explicitly enabled.
