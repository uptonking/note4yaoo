---
title: job-dev-faq
tags: [engineering, interview, work]
created: 2021-03-14T08:59:54.555Z
modified: 2021-09-22T16:36:05.615Z
---

# job-dev-faq

# guide

# tcp协议
- 特点
  - 面向连接的可靠传输：三次握手、四次挥手，传输可靠有序的字节流
  - 一一对应：一个 sender，一个 receiver
  - 缓冲：sender 与 receiver 都有缓存区
  - 全双工通信：在一条 TCP 连接中的双向数据流

## 三次握手

- 第一次——客户端请求连接： 
客户端随机初始化序号（client_isn），置于 TCP 首部的 seq 字段中，同时把 SYN 标志位置为 1 。把第一个 SYN 报文发送给服务端，该报文不包含应用层数据，之后客户端处于 SYN-SENT 状态	SYN=1
seq=client_isn

- 第二步——服务端确认 & 请求连接：
  - 服务端收到客户端的 SYN 报文后，随机初始化序号（server_isn）填入 TCP 首部 seq 中，设置 ACK=1 ，ack=client_isn + 1，接着把 SYN 标志置为 1。把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 SYN-RCVD 状态	SYN=1
ACK=1
seq=server_isn
ack=client_isn+1
ACK 和 ack：前者用于标注当前报文段的性质（SYN、ACK、FIN），后者用于向发送方确认已经收到的分组

- 第三步——客户端确认 & 传输数据： 
  - 客户端收到报文后需要发送确认，ACK=1，ack=server_isn + 1 ，seq=client_isn + 1 ，最后把报文发送给服务端，连接已经建立，这次报文可以携带客户到服务器的数据，之后客户端处于 ESTABLISHED 。服务器收到客户端的应答报文后，也进入 ESTABLISHED 状态	ACK=1
seq=client_isn+1
ack=server_isn+1

## 四次挥手

- 第一次——客户端请求断开： 
  - 开始双方都处于 ESTABLISHED 状态。当客户端想要断开连接：客户端发出连接释放报文段，置 FIN=1，seq=u，进入FIN-WAIT-1状态	FIN=1
seq=u
- 第二次——服务端确认请求： 
  - 服务器收到客户端报文后，发出确认报文段：ACK=1，ack=u+1，seq=v，进入CLOSE-WAIT状态。客户端收到服务器确认结果后，进入FIN-WAIT-2状态。	ACK=1
ack=u+1
seq=v
- 第三次——服务端请求断开： 
  - 当服务器完成所有发送后，发送连接释放报文段：FIN=1，ACK=1，ack=u+1，seq=w，服务器进入LAST-ACK（最后确认态）	FIN=1
ACK=1
ack=u+1
seq=w
- 第四步——客户端确认请求：
  -  客户端收到请求，发送确认报文段：ACK=1，ack=w+1，seq=u+1，进入TIME-WAIT（时间等待）。经过2个最长报文段寿命后，客户端CLOSE；服务器收到确认后，立刻进入CLOSE状态	ACK=1
ack=w+1
seq=u+1

- 【问题1】为什么是三次握手，不能仅有两次？
  - 假如不采用三次握手，那么只要 server 发出确认，新的建立就连接了，但当该  ACK 错误/冗余时，client 不会理睬 server的确认信息，也不会向服务端发送任何数据。但是server认为新的连接已经建立起来了，并一直等待 client 发来数据，这样，server的很多资源就没白白浪费掉了，采用三次握手就是为了防止这种情况的发生， server 会因为收不到确认的报文，就知道 client 并没有建立连接
- 【问题2】为什么连接的时候是三次握手，关闭的时候却是四次握手？
  - 因为当 server 收到 client 的 SYN 连接请求报文后，可以直接发送 SYN+ACK 报文。但是关闭连接时，当 server 收到 FIN 报文时，可能当前仍处于传输状态，并不会立即关闭 SOCKET ，只能先回复一个 ACK 报文，只有 server 确认所有的报文都发送完，才能发送 FIN 报文，因此不能一起发送。故需要四步握手。
- 【问题3】为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？
  - 必须认为网络是不可靠的，有可能最后一个 ACK 丢失。所以 TIME_WAIT 状态就是用来重发可能丢失的 ACK 报文。2MSL 就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client 推断 ACK 已经被成功接收，则结束 TCP 连接。

- 可靠数据传输
  - 网络层的IP服务不可靠，TCP需要在不可靠之上建立可靠数据传输服务：确保一个进程从其接收缓存中读出的是无损、有序、非冗余的数据流。
- rdt 实现的主要机制有：
  - 校验和（checksum）：检测分组的比特错误，接收方会丢弃出错的分组
  - 计时器（timer）：为了应对分组/ ACK 丢失或延迟，在 timeout 时重传分组
  - 序号（seq）：为从发送方流向接收方的分组按序编号，接收方因此可以检测到分组丢失
  - 确认号（ack）：接收方告诉发送方一个或一组分组已经被正确接收
  - 窗口、流水线：
    - RDT3.0 的停等协议保证了可靠传输，但性能孱弱，因为要求确认一个分组后才能发送下一个。流水线机制允许一次发送多个分组，提高了发送方的利用率，接收方则可缓存分组
    - 流水线机制可能遇到缓存溢出问题，因此有了"流量控制"
    - 为了包装流水线的传输可靠性问题，提出了 GBR 与 SR 算法

- TCP流量控制
  - 由于TCP在 sender/receiver 都具有buffer，为了避免处理速度不一致导致 receiver buffer溢出，数据丢失，需要进行流控，使得两端速度相一致
  - TCP 让 sender 维护一个接收窗口(receiver window)，用于提示 receiver 还有多少 buffer 可用，且全双工通信使得两端发送方各自维护一个窗口，对于发送方，即发送窗口

- TCP拥塞控制
  - 拥塞现象是指到达通信子网中某一部分的分组数量过多，使得该部分网络来不及处理，以致引起这部分乃至整个网络性能下降的现象，严重时甚至会导致网络通信死锁
  - 拥塞控制是链路上的控制（堵车发生在路上）；流量控制是S/R端的控制
  - 慢启动
  - 拥塞避免
    - 传输：如果进入拥塞避免，此时如果 cwnd 继续翻倍，很容易又进入拥塞，因此采用每次 cwnd增长一个MSS
    - 结束：丢包事件发生
  - 快速恢复
    - 立刻重传丢失的seg，cwnd 减半，每个冗余 ACK 使 cwnd++
# udp协议
- 特点
  - 无连接的：没有 s/r 之间的握手
  - 不总是可靠的：每个 UDP seg 都独立于其他 seg 被处理，可能丢包、乱序
  - header 更小
  - 无拥塞控制
# 如何在技术上进行seo优化
- SEO指搜索引擎优化，据百度的官方说法，相关性是排名的重要维度，前端布局或者说页面模型是相关性的重要组成部分
  - 包括关键词布局，内链调用机制，页面模型
- SEO最常用的HTML标签 
  - h1-h6, a, b/string, img[alt]
- HTML不同标签在SEO优化中的权重分数
  - 内部链接`<a>`: 10
  - 页面标题title：10
  - 域名：7
  - H1，H2字号标题：5
  - 每段首句：5
  - 路径或文件名：4
  - 相似度（关键词堆积）：4
  - 每句开头：1.5
  - 加粗或斜体：1
  - 文本用法（内容）：1
  - title属性：1分
  - alt标记：0.5
  - Meta描述（Description属性）：0.5
  - Meta关键词（Keywords属性）：0.05

- seo优化方向
  - 静态页面
  - 页面标题title的关键词
  - meta标签的优化（过去搜索引擎优化的重要手法，现在已经不是关键因素，但仍不可忽略）
  - 针对Google搜索引擎制作Sitemaps
  - 图片的关键词优化
  - 避免表格的嵌套
  - 网站结构的扁平化规划，目录和内容结构最好不要超过3层，如果有超过三层的，最好通过子域名来调整
# 进程与线程
- 进程是资源分配的最小单位，线程是CPU调度的最小单位
- 进程
  - 当执行一段程序时，会创建一个进程去执行代码，同时会为这个进程分配内存空间。
  - 该应用的状态都会保存在该内存空间中，当应用关闭时，该内存空间就会被回收。
  - 进程可以启动更多进程去执行任务。
  - 由于每个进程间的的内存空间是独立的，不同进程间的数据传输需要接触进程通信管道（IPC）来进行。
  - 很多应用都是多进程的结构，避免一个进程卡死后整个程序崩溃。
- 线程
  进程可以将一个任务分成更多细小的任务，然后通过创建多个线程，并行执行不同的任务，同一进程下的线程可以直接通信、共享数据。
  多个线程按一定方式占据 CPU 的时间片以执行任务，是调度过程的参与者

- 进程间通信即 IPC，其实现由多种方法
- 管道 pipe
  - 适合于父子进程间通信的方式，可视为一种文件，但只存在于内存中
- FIFO
  - 先进先出的队列。它类似于一个管道，只允许数据的单向流动
- 消息队列
  - 是消息的链表，存放在内核中。一个消息队列由一个标识符（即队列 ID）来标识。
  - 不同进程将格式化的数据流以消息形式发送给任意进程，该数据会被消息队列接收
  - 通过使用消息类型，进程可以按任何顺序读消息，或为消息安排优先级顺序
- 信号量 + 共享内存
  - 共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。
  - 因为多个进程可以同时操作，所以需要借助信号量进行同步。
  - 以简单的二元信号量为例，seg 只能为 0 或 1，当进程 A 读取内存时，使信号量减一，seg 变成 0，进程 B 想要访问内存时就会被堵塞，当 A 读取结束，信号量加一，seg 变回1，此时进程 B 恢复执行，开始读取数据。

# 小程序开发
- 小程序的渲染（wxml、wxss）和脚本执行（js）由两个层进行负责
  - 渲染：通过 webview（安卓中的空间，支持网页视图）实现，多个界面对应多个 webview 线程
  - 逻辑：通过 jsCore 负责执行
- 两层的线程通信会经由微信客户端（Native）做中转，逻辑层发送网络请求也经由 Native 转发
