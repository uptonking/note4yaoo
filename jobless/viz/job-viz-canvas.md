---
title: job-viz-canvas
tags: [canvas, job, viz]
created: 2021-10-15T16:03:22.633Z
modified: 2021-10-15T16:03:50.979Z
---

# job-viz-canvas

# guide

# 什么是 canvas 污染
- 将一张跨域的图片绘制到canvas上，这个canvas就是被污染的，此时无法读取该 canvas 的数据
  - 这个是同源策略的限制。应该是为了避免第三方网站读取其他网站的图片数据（Canvas渲染第三方图片请求不受 CORS 限制），避免用户隐私泄露。比如已知某个隐私图片的 url，进入第三方网站后，可以请求到该图片，如果不做数据读取限制的话，该数据将被传送到网站后台进而导致信息泄露。
- 有什么解决方案？
  - 这个要看能否控制图片的响应了。如果可以控制的话，利用 cors 跨域，并在图片请求发起时增加 crossOrigin = "Anonymous" 设置；否则只能自己的网站做个代理，让网站与图片同源。
- 为什么浏览器会有同源策略？
  - 为了限制其他源文档或脚本与当前源的资源进行交互。
  - 主要有两个地方：一个是 iframe 节点访问控制，如果没有同源策略限制的话，iframe 可以随意访问其他非同源 iframe 的 dom 节点，如钓鱼网站嵌套了一个银行网站的 iframe ，从外部就可以读取到内部密码输入框的值。
  - 另一个是 http 响应控制，如果没有同源策略限制的话，在第三方网站直接对其他网站发起请求，可以读取到响应，这样就可以获取用户的个人信息，造成隐私泄露。
- 刚刚说到响应控制，那请求是成功的么？
  - 利用 img/form 等支持跨域的标签，请求会自动带上 cookie，没有额外处理的话请求是成功的，这也就是所谓的 csrf 攻击。
  - 而如果是 ajax ，不会带上 cookie ，需要鉴权的请求也就直接失败。
  - 注意同源策略只是对终端进行信息防护，只拦截响应，不拦截请求。
- 为什么浏览器不直接拦截非同源请求？
  - 浏览器得通过响应才知道要不要拦截，如果直接拦截请求了，想用 cors 做跨域请求就做不了了。

- 说说 canvas 性能分析和常见的渲染优化策略？
# canvas简介
- Use the HTML `<canvas>` element with either the canvas scripting API or the WebGL API to draw graphics and animations.

- Canvas解决了什么问题
  - 在互联网出现的早期，Web 只不过是静态文本和链接的集合。1993 年，有人提出了 img 标签，它可以用来嵌入图像。
  - 但是随着 Web 应用的发展，出现了 HTML5，在 HTML5 中，浏览器中的媒体元素大受青睐。包括出现新的 Audio 和 Video 标签，可以直接将音频和视频资源放在 Web 上，而不需要其他第三方如flash。
- 其次就是为了解决只能在 Web 页面中显示静态图片的问题，出现了 Canvas 标签。
  - 它是一个绘图表面，包含一组丰富的 JavaScript API，这些 API 使你能够动态创建和操作图像及动画。
  - img对静态图形内容起到了哪些作用，Canvas 就可能对可编写脚本的动态内容起到哪

- svg 和 Canvas 的区别
- **svg本质上是一种使用 XML 描述2D图形的语言**。
  - svg可以用来定义 XML 格式的矢量图形。
  - svg 创建的每一个元素都是一个独立的 DOM 元素，既然是独立的 DOM 元素，那么我们就可以通过 css 和 JavaScript 来操控 dom。可以对每一个 DOM 元素进行监听。
  - 因为每一个元素都是一个 DOM 元素，所以修改 svg 中的 DOM 元素，系统会自动进行 DOM 重绘。
- Canvas 通过 JavaScript 来绘制 2D 图形
  - Canvas 只是一个 HTML 元素，其中的图形不会单独创建 DOM 元素。
  - 因此我们不能通过 JavaScript 操控 Canvas 内单独的图形，不能对其中的具体图形进行监控。
  - 在 Canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。
- **Canvas是基于像素的即时模式图形系统**，绘制完对象后不保存对象到内存中，当再次需要这个对象时，需要重新绘制；
  - **svg是基于形状的保留模式图形系统**，绘制完对象后会将其保存在内存中，当需要修改这个对象信息时，直接修改就可以了。
  - 这种根本的区别导致了很多应用场景的不同。
# [canvas典型案例简介](https://blog.csdn.net/weixin_43392489/article/details/108368993)
- Canvas是一个可以使用脚本（通常为Javascript，其它比如JavaFX/Flutter）来绘制图形，默认大小为300像素×150像素的HTML元素。

- 动画
  - requestAnimationFrame
  - 1. 避免掉帧 完全依赖浏览器的绘制频率，从而避免过度绘制，影响电池寿命。 
  - 2. 提升性能 当Tab或隐藏的iframe里，暂停调用。

- 个人做游戏总结的三要素：
  - 对象抽象
  - requestAnimationFrame
  - 缓动函数
- canvas.width则是控制画框尺寸的方式。
  - canvas.style.width则是控制在画框中的画尺寸的方式。

- canvas完全就是个画板，可任由我们发挥。 
  - 合成的思路其实就是把多张图片都画在同一个画布(cavans)里。
  - html2canvas为例，实现方式就是遍历整个dom，然后挨个拉取样式，在canvas上一个个地画出来。

- Uint8ClampedArray 8位无符号整型固定数组
  - 类型化数组表示一个由值固定在0-255区间的8位无符号整型组成的数组；
  - 如果你指定一个在 [0, 255] 区间外的值，它将被替换为0或255；
  - 如果你指定一个非整数，那么它将被设置为最接近它的整数。
  - （数组）内容被初始化为0。一旦（数组）被创建，你可以使用对象的方法引用数组里的元素，或使用标准的数组索引语法（即使用方括号标记）
  - index = [(y - 1) * w + (x - 1) ] * 4
- data里其实就是像素，按每4个为一组成为一个像素。 4个一组，难道是rgba？
  - 这样的话，图片的宽x高x4（w * h * 4 ）就是所有像素的总和，刚好就死data的length。

- createImageData
  - 是在canvas在取渲染上下文为2D（即canvas.getContext(‘2d')）的时候提供的接口。
  - 作用是创建一个新的、空的、特定尺寸的ImageData对象。其中所有的像素点初始都为黑色透明。并返回该ImageData对象。
- putImageData
  - putImageData方法作为canvas 2D API 以给定的ImageData对象绘制数据进位图。
  - 如果提供了脏矩形，将只有矩形的像素会被绘制。这个方法不会影响canvas的形变矩阵。

- 抠图
  - 对于纯背景抠图，其实还是比较简单的。上面我们已经说过，我们可以拿到整个canvas的每个像素点的值了。所以，只需要把纯色的色值转为透明就好了。 但这种场景不多，因为，背景很少有纯色的情况，而且即使背景纯色，不保证被扣对象的身上没有和背景同色值的情况。 
  - 所以，如果要处理复杂的情况，还是建议后端来做比较好，后端早已有了成熟的图像处理解决方案，比如opencv等。
  - 像美图的话，有专门的图像算法团队，天天研究这方面。
  - 接下来，我将介绍下美图人像抠图的思路。

- 粒子动画三要素
  - 粒子对象化
  - 缓动函数
  - 为了性能，粒子动画往往采用选择性的选取像素用来绘制。
