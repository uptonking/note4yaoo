---
title: job-algs-tree-faq
tags: [algorithms, job, tree]
created: '2021-09-28T05:47:32.382Z'
modified: '2021-09-28T05:47:56.650Z'
---

# job-algs-tree-faq

# guide

- 二叉树刷题小结
  - 中序遍历非常重要，bst中序遍历是有序递增的
  - 注意检查拼写错误和属性名书写，leetcode给的节点时.val，而不是.value
# 树的经典问题
- [面试算法知识梳理(10) - 二叉查找树](https://www.jianshu.com/p/2ae535fd8b01)
  - 建立二叉查找树
  - 删除二叉查找树中指定元素
  - 遍历
  - 分层打印二叉树
  - 打印二叉树的第 n 层
  - 统计二叉树的叶结点个数
  - 统计二叉树的高度
  - 获得二叉树的镜像
  - 判断元素是否存在于二叉树中
  - 打印二叉树中和为 s 的路径
  - 获得二叉树的最大距离
  - 判断二叉树是否是平衡树
  - 将二叉树转换成为链表
  - 判断数组是否为二叉查找树的后序遍历
  - 判断某树是否是另一棵树的子树
  - 根据先序遍历和中序遍历重建二叉树

- 判断某树是否是另一棵树的子树
  - 先判断父树和子树的根结点是否相等，如果相等，再比较两棵树是否完全相同，如果根结点不相等，那么再递归比较父树的左子树和子树，以及父树的右子树和子树。

## 重建二叉树

> 根据一棵树的前序遍历与中序遍历构造二叉树。注意: 你可以假设树中没有重复的元素。

- 已知两种遍历序列求原始二叉树
  - 通过先序和中序 或者 中序和后序我们可以还原出原始的二叉树
  - 但是通过先序和后序是无法还原出原始二叉树的

- 思路
  - 从前序遍历确定根结点
  - 在中序遍历找到根结点，将其分为左右子树
  - 根据中序遍历左右子树的个数，将前序遍历也分为对应的左右子树
  - 对左右子树的前序和中序再分别进行递归求解
  - 最后返回根节点
# 关于树的问题

## [有了二叉查找树、平衡树（AVL）为啥还需要红黑树？](https://zhuanlan.zhihu.com/p/72505589)

> 平衡树是为了解决二叉查找树退化为链表的情况
> 而红黑树是为了解决平衡树在插入、删除等操作需要频繁调整的情况。

- 二叉查找树的特点就是左子树的节点值比父节点小，而右子树的节点值比父节点大
  - 基于二叉查找树的这种特点，我们在查找某个节点的时候，可以采取类似于二分查找的思路
  - n 个节点的二叉查找树，正常的情况下，查找的时间复杂度为 O（logn）。
- 一种极端的情况，二叉查找树已经近似退化为一条链表，这样的二叉查找树的查找时间复杂度顿时变成了 O(n)
- **平衡二叉树就是为了解决二叉查找树退化成链表**的问题
  - 每个节点的左子树和右子树的高度差至多等于1。
  - 可以保证不会出现大量节点偏向于一边的情况了
- 平衡树要求每个节点的左子树和右子树的高度差至多等于1，这个**要求实在是太严了，导致每次进行插入/删除节点的时候，几乎都会破坏平衡树的第二个规则(左右子树高度差1)**，
  - 进而我们都需要通过左旋和右旋来进行调整，使之再次成为一颗符合要求的平衡树
- 如果在那种插入、删除很频繁的场景中，平衡树需要频繁着进行调整，这会使平衡树的性能大打折扣，为了解决这个问题，于是有了红黑树
  - 根节点是黑色的；
  - 每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存数据。
  - 任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的。
  - 每个节点，从该节点到达其可达的叶子节点是所有路径，都包含相同数目的黑色节点。
  - 使得它能够在最坏情况下，也能在 O(logn) 的时间复杂度查找到某个节点。
- 与平衡树不同的是，红黑树在插入、删除等操作，不会像平衡树那样，频繁着破坏红黑树的规则，所以不需要频繁着调整，这也是我们为什么大多数情况下使用红黑树的原因。
- 单单在查找方面的效率的话，平衡树比红黑树快。
  - 红黑树是一种不大严格的平衡树。也可以说是一个折中发方案。
