---
title: job-algs-base-sort
tags: [algorithms, job, sort]
created: '2021-09-24T19:46:02.713Z'
modified: '2021-09-24T19:46:42.224Z'
---

# job-algs-base-sort

> Sort Algorithms 经典排序算法

# guide

```JS
/**
 * 排序测试模版
 * @param {number[]} nums
 * @return {number[]}
 */
var sortArray = function(nums) {

};
```

# 00 Conclusions 总结
- 排序算法分类
  - 选择排序：直接选择排序、堆排序
  - 插入排序：直接插入排序、二分插入排序、希尔排序
  - 交换排序：冒泡排序、快速排序
  - 归并排序
  - 分配排序（非比较排序）：基数排序、计数排序、桶排序
  - 其他排序
    - 拓扑排序
    - 二分排序
   
- 结论
  - 平均速度最快：快速排序
  - 所需辅助空间最少：堆排序
  - 所需辅助空间最多：归并排序
  - 稳定性：直接插入排序、冒泡排序、归并排序 

> 排序算法的稳定性是指相同的值在排序过后相对位置不变

- 时间复杂度

| 算法          | 平均时间复杂度    |空间复杂度  | 稳定性度  |   备注     |
| :-----------: |:-------------:|:--------:|:--------:|:----------|
| 选择排序      |    O(N2)          |   O(1)  |   F     |  n小好     |
| 堆排序        |    O(N*logN)      |   O(1)  |   F     |  n大好     |   
| 插入排序      |    O(N2)          |   O(1)  |   T     |大部分有序好  |
| 希尔排序      |    O(N^m) `1<m<2` |  O(1)   |   F     |           |
| 冒泡排序      |    O(N2)          |   O(1)  |   T     |   n小好    |
| 快速排序      |    O(N*logN)      |O(logN)  |   F     |   n大好    |
| 归并排序      |    O(N*logN)      |   O(N)  |   T     |    n大好   |
| 基数排序      |    O(d(r+N))      | O(rd+N) |   T     |           |

- 桶排序平均时间复杂度也为O(N)

- 影响排序效果的因素  
  1)待排序的记录数目n；  
  2)记录的大小(规模)；  
  3)关键字的结构及其初始状态；  
  4)对稳定性的要求；  
  5)语言工具的条件；  
  6)存储结构；  
  7)时间和辅助空间复杂度等。   

- 方法选择  
  - 若n较小(如n≤50)，可采用直接插入或直接选择排序。  
    - 当记录规模较小时，直接插入排序较好；  
    - 否则因为直接选择移动的记录数少于直接插入，应选直接选择排序为宜。
  - 若文件初始状态基本有序(指正序)，则应选用直接插人、冒泡或随机的快速排序为宜；
  - 若n较大，则应采用时间复杂度为O(nlogn)的排序方法：快速排序、堆排序或归并排序。
    - 快速排序是目前基于比较的内部排序中**被认为是最好**的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短；   
    - 堆排序所需的辅助空间少于快速排序，并且不会出现快速排序可能出现的最坏情况。这两种排序都是不稳定的。  
    - 若要求排序稳定，则可选用归并排序。
      - 但本章介绍的从单个记录起进行两两归并的排序算法并不值得提倡，通常可以将它和直接插入排序结合在一起使用。
      - 先利用直接插入排序求得较长的有序子文件，然后再两两归并之。
      - 因为直接插入排序是稳定的，所以改进后的归并排序仍是稳定

- 参考资料
  - [Java常用排序算法-程序员必须掌握的8大排序算法](http://blog.csdn.net/qy1387/article/details/7752973)  
  - [八大排序算法总结与java实现](https://itimetraveler.github.io/2017/07/18/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E4%B8%8Ejava%E5%AE%9E%E7%8E%B0/)  
# 01 SelectSort 选择排序
- 基本原理
  - 在要排序的一组数中，选出最小的一个数与第一个位置的数交换；
  - 然后在剩下的数当中再找最小的与第二个位置的数交换，如此循环到倒数第二个数和最后一个数比较为止。
  
- 特征

**时间复杂度**   
**空间复杂度**   

**条件**
 

- 优点

- 缺点
 
- 应用场景
- 锦标赛排序
  - 两两比较，不足补无穷大，小的作为根，构造树

- 没必要用

- 复杂度O(logN)
# 02 InsertSort 插入排序
- 基本原理
  - 在要排序的一组数中，假设前面(n-1)[n>=2] 个数已经是排好顺序的，
  - 现在要把第n个数插到前面的有序数中，使得这n个数也是排好顺序的。
  - 如此反复循环，直到全部排好顺序。
- 特征

**时间复杂度**   
**空间复杂度**   

**条件**
 

- 优点

- 缺点
 
- 应用场景
# 03 ShellSort 希尔排序
- 基本原理
  - 先将要排序的一组数按某个增量d（n/2, n为要排序数的个数）分成若干组，每组中记录的下标相差d. 
  - 对每组中全部元素进行直接插入排序，然后再用一个较小的增量（d/2）对它进行分组，在每组中再进行直接插入排序。
  - 当增量减到1时，进行直接插入排序后，排序完成

- 特征

**时间复杂度** 
**空间复杂度** 

**条件**
 

- 优点

- 缺点
 
- 应用场景
# 04 MergeSort 归并排序
- 基本原理  
  - 将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。
  - 然后再把有序子序列合并为整体有序序列。
- 特征

**时间复杂度** 
**空间复杂度** 

**条件**
 

- 优点

- 缺点
 
- 应用场景
# 05 QuickSort 快速排序
- 基本原理
  - 选择一个基准元素, 通常选择第一个元素或者最后一个元素, 通过一趟扫描，将待排序列分成两部分, 
  - 一部分比基准元素小, 一部分大于等于基准元素, 此时基准元素在其排好序后的正确位置, 然后再用同样的方法递归地排序划分的两部分。  
- 特征

**时间复杂度** 
**空间复杂度** 

**条件**
 

- 优点

- 缺点
 
- 应用场景
  - 快速排序，枢纽元如果是重复的值，选择不同位置的相同元素，就可能破坏次序。  

# 06 HeapSort 堆排序
- 基本原理
  - 初始时把要排序的数的序列看作是一棵顺序存储的二叉树，调整它们的存储序，使之成为一个堆，这时堆的根节点的数最大。
  - 然后将根节点与堆的最后一个节点交换。然后对前面(n-1)个数重新调整使之成为堆。
  - 依此类推，直到只有两个节点的堆，并对它们作交换，最后得到有n个节点的有序序列。
  - 从算法描述来看，堆排序需要两个过程，一是建立堆，二是堆顶与堆的最后一个元素交换位置。
  - 所以堆排序有两个函数组成。一是建堆的渗透函数，二是反复调用渗透函数实现排序的函数。  

- 特征

**时间复杂度** 
**空间复杂度** 

**条件**
 

- 优点

- 缺点
 
- 应用场景
# 07 BubbleSort 冒泡排序
- 基本原理
  - 在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。
- 特征

**时间复杂度** 
**空间复杂度** 

**条件**
 

- 优点

- 缺点
 
- 应用场景
# 08 RadixSort 基数排序
- 基本原理
  - 将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。
  - 然后，从最低位开始，依次进行一次排序。这
  - 样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。
- 基数排序按照优先从高位或低位来排序有两种实现方案：
  - MSD（Most significant digital）   
    - 从最左侧高位开始进行排序。先按k1排序分组, 同一组中记录, 关键码k1相等, 再对各组按k2排序分成子组,
    -  之后, 对后面的关键码继续这样的排序分组, 直到按最次位关键码kd对各子组排序后. 再将各组连接起来, 便得到一个有序序列。  
    - MSD方式适用于位数多的序列。
  - LSD （Least significant digital）  
    - 从最右侧低位开始进行排序。先从kd开始排序，再对kd-1进行排序，依次重复，直到对k1排序后便得到一个有序序列。  
    - LSD方式适用于位数少的序列。

- 特征

**时间复杂度** 
**空间复杂度** 

**条件**
 

- 优点

- 缺点
 
- 应用场景
# 09 CountingSort 计数排序
- 基本原理

- 特征
  - 计数排序不是比较排序，排序的速度快于任何比较排序算法。  
  - 当输入的元素是n个0到k之间的整数时，它的运行时间是O(n+k)。  

**时间复杂度** 
**空间复杂度** 

- **条件**
  - 只针对0和正整数

- 优点

- 缺点
 
- 应用场景
- 计数排序需要占用大量空间，它仅适用于数据比较集中的情况
  - 计数排序对于数据范围很大的数组，需要大量时间和内存，适用性不高。  
  - 例如：计数排序是用来排序0到100之间的数字的最好的算法，但是它不适合按字母顺序排序人名。  
  - 但计数排序可以用在基数排序中的算法来排序数据范围很大的数组。  
  - 当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是 Θ(n + k)。

# 10 BucketSort 桶排序
- 基本原理
- 桶排序，也称箱排序，使用分治的思想  
  a. 将待排序的数据按映射函数分成连续的若干段，最好使数据平均分布  
  b. 确定桶数量  
  c. 每个桶内部排序  
  d. 按顺序输出数据  
- 假设数组元素最大值和最小值分别为max和min，则桶的个数为max - min + 1，
  - 也即数组区间[min, max]每个元素和桶下标区间[0, max - min + 1]中每个元素一一对应，这也是桶排序的核心思想。
- 特征

**时间复杂度** O(M+N) M是桶个数（一般为最大数），N是待排序个数
**空间复杂度** O(n)

**条件**
 

- 优点

- 缺点
 
- 应用场景
