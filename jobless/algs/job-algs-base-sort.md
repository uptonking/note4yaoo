---
title: job-algs-base-sort
tags: [algorithms, job, sort]
created: '2021-09-24T19:46:02.713Z'
modified: '2021-09-24T19:46:42.224Z'
---

# job-algs-base-sort

> Sort Algorithms 经典排序算法

# guide
- tips
  - 不必执着于哪个是性能最高的算法，影响排序的因素很多
    - 常见因素包括数量多少、极值分布、空间要求、稳定性等
    - 经常碰到数据预处理和类型转换比排序用时更多的情况

```JS
/**
 * 排序测试模版；
 * 在线oj测试 https://leetcode-cn.com/problems/sort-an-array/
 * @param {number[]} nums
 * @return {number[]}
 * 
 */
var sortArray = function(nums) {};
```

# Conclusions 总结
- 排序算法分类
  - 选择排序：直接选择排序、堆排序
  - 插入排序：直接插入排序、二分插入排序、希尔排序
  - 交换排序：冒泡排序、快速排序
  - 归并排序
  - 分配排序（非比较排序）：基数排序、计数排序、桶排序
  - 其他排序算法
    - 拓扑排序
    - 二分排序
- 时间复杂度
| 算法          | 平均时间复杂度    |空间复杂度  | 稳定性度  |   备注     |
| :-----------: |:-------------:|:--------:|:--------:|:----------|
| 选择排序      |    O(N2)          |   O(1)  |   F     |  n小好     |
| 堆排序        |    O(N*logN)      |   O(1)  |   F     |  n大好     |
| 插入排序      |    O(N2)          |   O(1)  |   ✅️     |大部分有序好 |
| 希尔排序      |    O(N^m) `1<m<2` |   O(1)  |   F      |           |
| 冒泡排序      |    O(N2)          |   O(1)  |   ✅️     |   n小好    |
| 快速排序      |    O(N*logN)      |O(logN)  |   F      |   n大好    |
| 归并排序      |    O(N*logN)      |   O(N)  |   ✅️     |   n大好   |
| 基数排序      |    O(d(r+N))      | O(rd+N) |   T      |           |
- 复杂度说明
  - 桶排序平均时间复杂度也为O(N)
- 排序算法总结
  - 平均速度最快：快速排序
  - 所需辅助空间最少：堆排序
  - 所需辅助空间最多/非就地排序：归并排序
  - 具有稳定性的排序算法：插入排序、冒泡排序、归并排序
- 稳定性
  - 假定在待排序的记录序列中存在多个具有相同的关键字的记录，
  - 若经过排序，这些记录的相对次序保持不变则称这种排序算法是稳定的，否则称为不稳定的
- 原地性
  - 原地排序就是指在排序过程中不申请多余的存储空间，只利用原来存储待排数据的存储空间进行比较和交换的数据排序
- 影响排序效果的因素
  - 待排序的记录数目n
  - 记录的大小
  - 关键字的结构及其初始状态
  - 对稳定性的要求
  - 语言工具的条件
  - 存储结构
  - 时间和辅助空间复杂度等
- 方法选择  
  - 若n较小(如n≤50)，可采用直接插入或直接选择排序。
    - 当记录规模较小时，直接插入排序较好；
    - 否则因为直接选择移动的记录数少于直接插入，应选直接选择排序为宜。
  - 若文件初始状态基本有序(指正序)，则应选用直接插人、冒泡或随机的快速排序为宜；
  - 若n较大，则应采用时间复杂度为O(nlogn)的排序方法：快速排序、堆排序或归并排序。
    - 快速排序是目前基于比较的内部排序中**被认为是最好**的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短；
    - 堆排序所需的辅助空间少于快速排序，并且不会出现快速排序可能出现的最坏情况。这两种排序都是不稳定的。  
    - 若要求排序稳定，则可选用归并排序。
      - 但本章介绍的从单个记录起进行两两归并的排序算法并不值得提倡，通常可以将它和直接插入排序结合在一起使用。
      - 先利用直接插入排序求得较长的有序子文件，然后再两两归并之。
      - 因为直接插入排序是稳定的，所以改进后的归并排序仍是稳定

- Introsort 内省排序
  - 首先从快速排序开始，当递归深度超过一定深度（深度为排序元素数量的对数值）后转为堆排序。

- 参考资料
  - [Java常用排序算法-程序员必须掌握的8大排序算法](http://blog.csdn.net/qy1387/article/details/7752973)  
  - [八大排序算法总结与java实现](https://itimetraveler.github.io/2017/07/18/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E4%B8%8Ejava%E5%AE%9E%E7%8E%B0/) 
  - [几种常见排序方法的优化](https://jasonkayzk.github.io/2020/02/24/%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95%E7%9A%84%E4%BC%98%E5%8C%96-%E4%B8%8B/)
# 01 SelectionSort 选择排序

## 原理

- 实现思路
  - 在要排序的一组数中，选出最小的一个数与第一个位置的数交换；
  - 然后在剩下的数当中再找最小的与第二个位置的数交换，如此循环到倒数第二个数和最后一个数比较为止。
- 思路有点类似插入排序，也分已排序区间和未排序区间。
  - 但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。
- 特征
**条件**
- 优点
- 缺点
 
- 应用场景
- 锦标赛排序
  - 两两比较，不足补无穷大，小的作为根，构造树
- 没必要用
- 复杂度O(logN)

## js实现

```JS
/** 💡️ 内层循环仅选出最小索引但不交换 */
function selectionSort(nums) {
  // 每次循环处理从i开始的元素序列
  for (let i = 0; i < nums.length - 1; i++) {
    // 每次循环要找出最小元素的索引
    let min = i;
    for (let j = i; j < nums.length; j++) {
      if (nums[j] < nums[min]) {
        min = j;
      }
    }
    let temp = nums[i];
    nums[i] = nums[min];
    nums[min] = temp;
  }
  return nums
}

// 减少了内层循环的计算量
function selectionSort2(nums) {
  // 第i个未排序的元素
  for (let i = 0; i < nums.length - 1; i++) {
    let j = i;
    // 每次循环要找出最小元素的索引
    let min = j;
    while (j < nums.length) {
      // 在内层循环中每次选出最小的
      if (nums[j] < nums[min]) {
        min = j;
      }
      j++;
    }
    // 将最小的元素交换到第i个位置，i及其左边都是排好序的了
    let temp = nums[i];
    nums[i] = nums[min];
    nums[min] = temp;
  }
  return nums
}
```

- ref
  - [选择排序](https://github.com/doocs/leetcode/blob/main/basic/sorting/SelectionSort/README.md)
# 02 insertionSort 直接插入排序

## 原理

- 实现思路
  - 在要排序的一组数中，假设前面(n-1)[n>=2]个数已经是排好顺序的，现在要把第n个数插到前面的有序数中，使得这n个数也是排好顺序的。
  - 如此反复循环，直到全部排好顺序。
  - 在插入排序中，经过每一轮的排序处理后，数组前端的数是排好序的。
- 特征
**条件**
 
- 优点
- 缺点
 
- 应用场景

## js实现

```JS
/** 💡️ 从后往前逐个比较并交换 */
function insertionSort(nums) {
  // 将第i项作为待插入项
  for (let i = 1; i < nums.length; i++) {
    for (let j = i; j > 0 && nums[j] < nums[j - 1]; j--) {
      let temp = nums[j];
      nums[j] = nums[j - 1];
      nums[j - 1] = temp;
    }
  }
  return nums;
}

function insertionSort2(nums) {
  // 将数组第1个元素看成有序序列，开始处理第2,3,4...个元素
  for (let i = 1; i < nums.length; i++) {
    // 每次循环都要将当前项插入到有序序列的正确位置
    let temp = nums[i];
    let j = i - 1;
    // 从已排好序的前段数组的末尾开始，将比较项往前移
    while (nums[j] > temp && j > 0) {
      nums[j + 1] = nums[j];
      j--;
    }
    // 若temp比所有项都大，则放在已排好序的末尾
    nums[j + 1] = temp;
  }
  return nums;
}
```

- ref
  - [插入排序](https://github.com/doocs/leetcode/blob/main/basic/sorting/InsertionSort/README.md)
# 03 ShellSort 希尔排序

## 原理

- 实现思路
  - 先将要排序的一组数按某个增量d（n/2, n为要排序数的个数）分成若干组，每组中记录的下标相差d. 
  - 对每组中全部元素进行直接插入排序，然后再用一个较小的增量（d/2）对它进行分组，在每组中再进行直接插入排序。
  - 当增量减到1时，进行直接插入排序后，排序完成
- 希尔排序，也被称为递减增量排序，是简单插入排序的一种改进版本。
  - 在插入排序中，如果待排序列中的某个元素，距离有序数列中待插入位置非常远，就需要比较很多次才可以到达插入位置
  - 希尔排序就是先把整个序列排得相对比较有序，再进行插入排序的时候，需要比较的次数就会变得很少。
  - 插入排序的增量(间隔)为 1，希尔排序相当于将这个间隔从最大为数组长度的一半一直降到 1
  - 希尔排序就是将处在相同间隔的元素提取出来单独进行插入排序，然后逐步将间隔减小到 1 的过程。
- 特征
**时间复杂度** 
**空间复杂度** 
**条件**
 
- 优点
- 缺点
 
- 应用场景

## js实现

```JS
/** 💡️ 注意边界条件要正确处理，思路与直接插入排序基本相同 */
function shellSort(nums) {
  const len = nums.length;
  for (let gap = Math.floor(len / 2); gap >= 1; gap = Math.floor(gap / 2)) {
    for (let i = gap; i < len; i += gap) {
      for (let j = i; j > 0 && nums[j] < nums[j - gap]; j -= gap) {
        const temp = nums[j];
        nums[j] = nums[j - gap];
        nums[j - gap] = temp;
      }
    }
  }
  return nums;
}
```

- ref
  - [希尔排序](https://github.com/doocs/leetcode/blob/main/basic/sorting/ShellSort/README.md)
# 04 MergeSort 归并排序

## 原理

- 实现思路
  - 归并排序的核心思想是分治，把一个复杂问题拆分成若干个子问题来求解。
  - 把数组从中间划分为两个子数组，一直递归地把子数组划分成更小的数组，直到子数组里面只有1个元素的时候开始排序。
  - 排序的方法就是按照大小顺序合并两个元素。接着依次按照递归的顺序返回，不断合并排好序的数组，直到把整个数组排好序。
- 特征
**时间复杂度** 
**空间复杂度** 
**条件**
 
- 优点
  - 归并排序的效率达到了巅峰：时间复杂度为O(nlogn)，这是基于比较的排序算法所能达到的最高境界
  - 归并排序是一种稳定的算法，这一点在某些场景下至关重要
  - 归并排序是最常用的外部排序方法（当待排序的记录放在外存上，内存装不下全部数据时，归并排序仍然适用，当然归并排序同样适用于内部排序）

- 缺点
  - 归并排序需要O(n)的辅助空间，而与之效率相同的快排和堆排分别需要O(logn)和O(1)的辅助空间，在同类算法中归并排序的空间复杂度略高
 
- 应用场景
- Top K 问题
  - 堆化，取前 K 个元素
- 中位数问题
  - 维护两个堆，一大（前50%）一小（后50%），奇数元素取大顶堆的堆顶，偶数取取大、小顶堆的堆顶

- [K路归并排序与败者树](https://blog.csdn.net/mcryeasy/article/details/84935989)
- 大文件的排序问题
  - 有一个文件大小为10GB，现在要为里面的数据进行排序，而计算机的内存只有1GB，如何对这10GB的数据进行排序呢？
  - 需要借助外部排序来解决。外部排序的思路很简单，它采用了一种" 排序-归并 " 的策略。
  - 把10GB文件大小分为10份，每一份1GB。
  - 依次把每份文件读取到内存中进行排序，可采用快排、归并、堆排等，然后把排序后的数据写入到磁盘中，这样每一份的文件数据都是有序的。
  - 对10个有序的文件，进行两两归并。既把每两个文件中的部分数据读取到内存中进行比较，然后把比较后的结果输出到临时文件中，最终得到的临时文件就是两个小文件整合在一起的有序文件 。然后把该临时文件和其他临时文件再进行两两归并，依次类推，最终输出的文件就是一个有序的文件。
  - 每次都由 m 个归并段得到 ⌈m/2⌉ 个归并段，这种归并方式被称为 2路归并排序。
- 对于外部排序算法来说，影响整体排序效率的因素主要取决于读写磁盘的次数，即访问磁盘的次数越多，算法花费的时间就越多，效率就越低。
  - 而对于同一个文件来说，对其进行外部排序时访问外存的次数同归并的次数成正比，即归并操作的次数越多，访问外存的次数就越多。
  - 为了提高外部排序的效率，降低归并次数，所以出现了4路排序、5路排序、10路排序等K路排序。
  - 当有10个文件， 进行2路归并，需要进行4次归并操作，而进行5路归并，则只需要2次归并操作。
  - 因此对于k路平归并排序中 k 值得选择，增加 k 可以减少归并的次数，从而减少外存读写的次数，最终达到提高算法效率的目的。
  - 假设有m个文件采用K路进行归并时，那么归并的次数为：s =log­k(m)（其中s为归并的次数）。
- 想要达到减少归并次数s从而提高算法效率的目的，可以从两个角度
  - 增加 K路平衡归并中的 K 值，可采用多路平衡归并排序算法解决。
  - 尽量减少初始归并段的数量 m，即增加每个归并段的容量，可采用置换-选择排序算法解决。
- 要想减少归并的次数，可以增加K的值。
  - 但是，如果毫无限度地增加K的值，虽然会减少归并次数，但是会增加内部归并的时间。
  - 以10 个文件为例子，当采用 2归并时，若每次从 2 个文件中想得到一个最小值时只需比较 1 次；而采用 5路归并时，若每次从 5 个文件中想得到一个最小值就需要比较 4 次。因此K值越大比较的次数就多！
  - 为了避免K 值的选择过程中影响内部归并的效率，在进行 K路归并时可以使用败者树来实现，该方法让K值的不会影响其内部归并的效率。
- 败者树实现多路平衡归并
  - 实现方式是让K路归并中的每一路第一个元素构建成一颗败者树
  - 败者树是多路归并算法中其中一种优化方案，其他的优化方案还有通过最小堆来实现置换选择排序算法，减少m的分片个数，进而提高归并的效率，以及还有最佳归并树等方案

## 优化

- 1. **对小规模子数组使用插入排序**
  - 当规模较小时，有时候分治算法效率是不如普通算法的。
  - 插入排序中包含的常数因子较小，使得当 n 较小时, 算法运行得更快。
  - 当数组递归子序列的规模在一个固定阀值(阀值指数组的最大长度)以下时, 采用插入排序对子序列进行排序, 能够缩短排序时间。
  - 一般阀值选取在 7-10 个元素，我记得Java里的Arrays.sort()方法好像是用的7个元素（当元素是基本类型时sort用的是优化版快排，当元素是对象时用的是归并排序，因为对于对象需要稳定性）。
  - 用不同的方法处理小规模问题能改进大多数递归算法的性能，因为递归会使小规模问题中方法调用太过频繁，所以改进对它们的处理方法就能改进整个算法。 这种优化能使归并排序的运行时间缩短10%到15%；

- 2. 测试待排序序列中左右半边是否已有序
  - 通过测试待排序序列中左右半边是否已经有序，在有序的情况下避免合并方法的调用。

- 3. 去除原数组序列到辅助数组的拷贝
  - 不将元素复制到辅助数组，节省数组复制的时间。
  - 调用两种排序方法，一种：将数据从输入数组排序到辅助数组；另一种：将数据从辅助数组排序到输入数组。

- 4. 直接将辅助数组作为参数传入，而不直接使用静态数组。

- ref
  - [前端进阶算法9： 堆排序、Top K、中位数问题](https://github.com/sisterAn/JavaScript-Algorithms/issues/60)
  - [归并排序算法的编码和优化](https://www.cnblogs.com/penghuwan/p/7940440.html)
  - [从2路归并到k路归并](https://juejin.cn/post/6883783242928488455)
 

## js实现

```JS
/** 💡️ 递归版 先递归的拆分数组，再两两合并  */
export function mergeSort(nums) {
  const len = nums.length;
  if (len <= 1) {
    return nums;
  }

  const mid = Math.floor(len / 2);

  const left = nums.slice(0, mid);
  const right = nums.slice(mid);

  return merge(mergeSort(left), mergeSort(right));
}

/** 合并2个数组成有序数组 */
function merge(left, right) {
  const tempArr = [];

  while (left.length && right.length) {
    if (left[0] < right[0]) {
      tempArr.push(left.shift());
    } else {
      tempArr.push(right.shift());
    }
  }

  return [...tempArr, ...left, ...right];
}
```

- ref
  - [用 JavaScript 实现归并排序](https://segmentfault.com/a/1190000037697664)
  - [JavaScript实现归并排序-递归法与非递归法](https://blog.csdn.net/q918922703_1/article/details/101211914)
# 05 QuickSort 快速排序

## 原理

- 实现思路
  - 在数组中选择一个元素，这个元素被称为基准（Pivot）。通常把数组中的第一个或最后一个元素作为基准。
  - 然后，重新排列数组的元素，以使基准左侧的有元素都小于基准，而右侧的所有元素都大于基准。这一步称为分区。
  - 如果一个元素等于基准，那么在哪一侧都无关紧要。
  - 针对基准的左侧和右侧分别重复这一过程，直到对数组完成排序。

- 快速排序也采用了分治的思想
  - 把原始的数组筛选成较小和较大的两个子数组，然后递归地排序两个子数组。(就地排序时没有新建子数组)

- 特征
**时间复杂度** 
**空间复杂度** 
**条件**
 
- 优点
- 缺点
 
- 应用场景
  - 快速排序，枢纽元如果是重复的值，选择不同位置的相同元素，就可能破坏次序。

## 优化

- 1. 当待排序序列的长度分割到一定大小后，使用插入排序。
  - 当待排序序列的长度分割到一定大小后，继续分割的效率比插入排序要差，此时可以使用插排而不是快排
  - 截止范围：待排序序列长度 N = 10，虽然在5~20之间任一截止范围都有可能产生类似的结果，这种做法也避免了一些有害的退化情形。摘自《数据结构与算法分析》Mark Allen Weiness 著

- 2. 在一次分割结束后，可以把与Key相等的元素聚在一起，继续下次分割时，不用再对与key相等元素分割
  - 在数组中，如果有相等的元素，那么就可以减少不少冗余的划分。这点在重复数组中体现特别明显

- 3. 优化递归操作
  - 快排函数在函数尾部有两次递归操作，我们可以对其使用尾递归优化
  - 如果待排序的序列划分极端不平衡，递归的深度将趋近于n，而栈的大小是很有限的，每次递归调用都会耗费一定的栈空间，函数的参数越多，每次递归耗费的空间也越多。
  - 优化后，可以缩减堆栈深度，由原来的O(n)缩减为O(logn)，将会提高性能。

- 4. 针对排序基准轴优化
  - 三数取中法：
    - 指的是选取基准点之前我们可以拿出数列中间位置元素的值，将它和首尾的元素进行比较，之后将这三个数中的中间大的数交换到数列首位的位置，
    - 之后将这个数作为基准点，尽量减小之后的分区后左右两边的区间长度之差。
  - 随机交换法：
    - 指的是选取基准点之前设计随机种子，通过随机函数得到一个在数列长度内的数，将这个随机数作为索引所指的数和第一个元素进行交换，之后将首位元素作为基准点。
    - 即随机选一个数放到首位的地方。这样一来，第一次就将最小的数交换到首位的概率是非常小的，第二次将次小的数交换到首位的概率依然非常的小。

- 5. 针对数列含有大量重复元素的情况
  - 在之前的分区算法中，由于含有大量的重复数据，将会导致分出来的左右区间，两个区间的长度比例完全失衡，导致了算法的时间复杂度上升，
  - 针对这种情况，需要对分区操作做适当的修改，思路是将小于基准点的数全部放到左边，大于基准点的数全部放到右边，

- 6. 3路法
  - 3路法同样是针对含有大量重复数列的优化
  - 3路法的思想是将数列分成3个区间，分别是小于、等于和大于基准点的区间，那么分区之后，对于等于基准点的区间内的元素，我们就不需要对其做任何处理了，只需要递归的处理小于和大于基准点的元素即可。

- 7. 排序前的有序性检查
  - 用来排序的数组经常会出现有序片段。
  - 两个前提：一，对有序数组进行排序是无意义，浪费时间的；二，检查数组是否有序时间复杂度很低，只需要O(n)。
  - 基于这两个前提，可以在快速排序算法的每个递归子数组排序前进行有序性检查，无序时才进行排序操作。

- 8. 多线程快排

- ref
  - [用 JavaScript 实现快速排序](https://segmentfault.com/a/1190000037611587)

## js实现

```JS
/**  💡️ splice + concat  */
function quickSort(nums) {
  if (nums.length <= 1) {
    return nums;
  }
  let pivotIndex = Math.floor(nums.length / 2);
  // 从数组中去掉基准值，并获取这个基准值
  let pivot = nums.splice(pivotIndex, 1)[0];
  let left = [];
  let right = [];
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] < pivot) {
      left.push(nums[i])
    } else {
      right.push(nums[i])
    }
  }
  return [...quickSort(left), pivot, ...quickSort(right)]
  // return quickSort(left).concat([pivot], quickSort(right));
}
```

- ref
  - [js算法-快速排序(Quicksort)](https://segmentfault.com/a/1190000017814119)

## 三路快速排序

- 3-way quick sort and quick sort using two pivots are two different things.

- 3-way quick sort: 
  - It is used when arrays with large number of duplicate sort keys arise frequently.
  - In this algorithm the array partitioned into three parts:
  - 1)one with is < v
  - 2)equal to = v
  - 3)one with > v

- Quick sort using two pivots:
  - Also called as Dual-Pivot Quicksort algorithm by Vladimir Yaroslavskiy. 
  - This also divides the array into three parts defined by two pivot elements P1 and P2
# 06 HeapSort 堆排序

## 原理

- 实现思路
  - 初始时把要排序的数的序列看作是一棵顺序存储的二叉树，调整它们的存储顺序，使之成为一个堆，这时堆的根节点的数最大。
  - 然后将根节点与堆的最后一个节点交换。然后对前面(n-1)个数重新调整使之成为堆。
  - 依此类推，直到只有两个节点的堆，并对它们作交换，最后得到有n个节点的有序序列。
  - 从算法描述来看，堆排序需要两个过程，一是建立堆，二是堆顶与堆的最后一个元素交换位置。
  - 所以堆排序有两个函数组成。一是建堆的渗透函数，二是反复调用渗透函数实现排序的函数。  
  - 堆的存储： 堆由数组来实现，相当于对二叉树做层序遍历。
  - 对于结点i(i为节点所在数组的索引号)，其子结点为 2i+1 与 2i+2，其父节点为 Math.floor((i+1)/2))-1 或 Math.ceil(i/2)-1 
- 特征
**时间复杂度** 
**空间复杂度** 
**条件**
 
- 优点
- 缺点
 
- 应用场景
- 优先级队列
  - JDK中自带的PriorityQueue就是用堆实现的优先级队列
  - Top K 问题
  - 中位数

## 优化

- 使用原地堆排序

- 优化交换值的间隔
  - 堆中从根节点到叶节点的一条路径是有序的，最大堆是降序，我们在shiftDown操作时，实际上是在找根节点在某条路径上的一个插入位置，
  - 可以借鉴二分的思想，我们可以一次下降到当前高度h的一半的位置（在下降的过程中要将沿途的较大的子节点上移，这样在h/2高度形成空位），即h/2

## js实现

```JS
/** 💡️ heapSort 排序算法模版，非递归版 */
export function heapSort(nums) {
  const len = nums.length;
  if (len <= 1) {
    return nums;
  }

  for (let i = Math.floor(len / 2 - 1); i >= 0; i--) {
    heapifyMax(nums, i, len);
  }

  for (let j = len - 1; j >= 0; j--) {
    swap(nums, 0, j);
    // j可以代表本轮未排序元素个数
    heapifyMax(nums, 0, j);
  }

  return nums;
}

function heapifyMax(nums, i, heapSize) {
  for (let j = 2 * i + 1; j < heapSize; j = 2 * j + 1) {
    if (j + 1 < heapSize && nums[j] < nums[j + 1]) {
      j++;
    }

    if (nums[j] > nums[i]) {
      swap(nums, j, i);
      i = j;
    } else {
      break;
    }
  }
}
```

- ref
  - [JS实现堆排序](https://segmentfault.com/a/1190000015487916)
# 07 BubbleSort 冒泡排序

## 原理

- 实现思路
  - 比较每相邻两个数，如果前者大于后者，就把两个数交换位置；这样一来，第一轮就可以选出一个最大的数放在最后面
- 特征
**时间复杂度** 
**空间复杂度** 
**条件**
 
- 优点
- 缺点
 
- 应用场景

## js实现

```JS
/** 💡️ 将较大值后移 */
function bubleSort(nums) {
  let swapped = false;
  for (let i = 0; i < nums.length - 1; i++) {
    swapped = false;
    for (let j = 0; j < nums.length - 1 - i; j++) {
      if (nums[j] > nums[j + 1]) {
        const t = nums[j];
        nums[j] = nums[j + 1];
        nums[j + 1] = t;
        swapped = true;
      }
    }
    // 如果某次循环完后，没有任何两数进行交换，就将标志位设置为 true，表示排序完成
    if (!swapped) break;
  }
  return nums;
}
```

# 08 RadixSort 基数排序
- 基本原理
  - 将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。
  - 然后，从最低位开始，依次进行一次排序。这
  - 样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。
- 基数排序按照优先从高位或低位来排序有两种实现方案：
  - MSD（Most significant digital）   

    - 从最左侧高位开始进行排序。先按k1排序分组, 同一组中记录, 关键码k1相等, 再对各组按k2排序分成子组,
    -  之后, 对后面的关键码继续这样的排序分组, 直到按最次位关键码kd对各子组排序后. 再将各组连接起来, 便得到一个有序序列。  
    - MSD方式适用于位数多的序列。

  - LSD （Least significant digital）  

    - 从最右侧低位开始进行排序。先从kd开始排序，再对kd-1进行排序，依次重复，直到对k1排序后便得到一个有序序列。  
    - LSD方式适用于位数少的序列。

- 特征
**时间复杂度** 
**空间复杂度** 
**条件**
 
- 优点
- 缺点
 
- 应用场景
# 09 CountingSort 计数排序

- 基本原理
- 特征
  - 计数排序不是比较排序，排序的速度快于任何比较排序算法。  
  - 当输入的元素是n个0到k之间的整数时，它的运行时间是O(n+k)。  
**时间复杂度** 
**空间复杂度** 
- **条件**
  - 只针对0和正整数
- 优点
- 缺点
 
- 应用场景
- 计数排序需要占用大量空间，它仅适用于数据比较集中的情况
  - 计数排序对于数据范围很大的数组，需要大量时间和内存，适用性不高。  
  - 例如：计数排序是用来排序0到100之间的数字的最好的算法，但是它不适合按字母顺序排序人名。  
  - 但计数排序可以用在基数排序中的算法来排序数据范围很大的数组。  
  - 当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是 Θ(n + k)。

# 10 BucketSort 桶排序
- 基本原理
- 桶排序，也称箱排序，使用分治的思想  
  a. 将待排序的数据按映射函数分成连续的若干段，最好使数据平均分布  
  b. 确定桶数量  
  c. 每个桶内部排序  
  d. 按顺序输出数据  
- 假设数组元素最大值和最小值分别为max和min，则桶的个数为max - min + 1，
  - 也即数组区间[min, max]每个元素和桶下标区间[0, max - min + 1]中每个元素一一对应，这也是桶排序的核心思想。
- 特征
**时间复杂度** O(M+N) M是桶个数（一般为最大数），N是待排序个数
**空间复杂度** O(n)
**条件**
 
- 优点
- 缺点
 
- 应用场景
