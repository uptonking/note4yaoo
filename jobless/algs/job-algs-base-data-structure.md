---
title: job-algs-base-data-structure
tags: [algorithms, data-structure, job]
created: '2021-09-24T19:47:40.276Z'
modified: '2021-09-24T19:48:07.178Z'
---

# job-algs-base-data-structure

# guide

# string

# array

# map

# graph

- 生成树  
  - 连通图G的一个子图如果是一棵包含G的所有顶点的树，则该子图称为G的生成树 
- 带权图分为有向和无向，
  - 无向图的最短路径又叫做最小生成树，有prime算法和kruskal算法；
  - 有向图的最短路径算法有dijkstra算法和floyd算法。
- 最小生成树  
  - 能够保证整个拓扑图的所有路径之和最小，但不能保证任意两点之间是最短路径
- SPFA（Shortest Path Faster Algorithm）（队列优化）算法  
  - 是求单源最短路径的一种算法，它还有一个重要的功能是判负环（在差分约束系统中会得以体现），在Bellman-ford算法的基础上加上一个队列优化，减少了冗余的松弛操作，是一种高效的最短路算法。

- 拓扑排序
- 将有向无环图中的顶点以线性方式进行排序
- 即对于任何连接自顶点u到顶点v的有向边uv，在最后的排序结果中，顶点u总是在顶点v的前面
- 基于减治法实现
  - 不断地做这样一件事，在余下的有向图中求取一个源（source）（PS：定义入度为0的顶点为有向图的源），它是一个没有输入边的顶点，然后把它和所有从它出发的边都删除。
  - （如果有多个这样的源，可以任意选择一个。如果这样的源不存在，算法停止，此时该问题无解）  
- 基于深度优先遍历来实现拓扑排序
- bfs是就是按照拓扑顺序，从前往后找, 找到入度为0的顶点就进行输出，
- 而深度优先搜索dfs则是从后往前推，在不断深入图，找到最后没有后继结点，就放在输出队列一开始，之后在不断递归返回时，再将其他没有后继节点的节点放在输出队列的开头，那么这样就会保证一开始进入输出队列的最深处的节点在最后输出，保证满足拓扑顺序
