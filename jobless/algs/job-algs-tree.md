---
title: job-algs-tree
tags: [algorithms, job, tree]
created: 2021-09-21T19:41:38.307Z
modified: 2021-09-21T19:45:13.231Z
---

# job-algs-tree

# guide

# 常用 tree 数据结构

## tree相关概念

- 树是由 n（n>0）个有限节点组成一个具有层次关系的集合
  - 👀 从图论的角度，树等价于连通无环图，由一组顶点（vertex） 以及联接与其间的若干条边（edge）组成
  - 指定某一特定顶点为根（root），也称之为有根树（rooted tree）
  - 根据树的无环性，由根通往每个节点的路径必然唯一

- tree特点
  - 有且仅有一个成为根的节点
  - 每一个非根节点有且只有一个父节点
  - 除了根节点外，每个子节点可以分为多个不相交的子树
  - 树里面没有环路

- 高度 (从当前节点到叶，叶节点高度0)
  - 对于任意节点n，节点n的高度为从n到叶节点的最长路径长，所有树叶的高度为 0。
  - 高度指的是路径长，也就是最长路径上的“边”数，而不是路径上的“节点”数
  - 树的高度 (Height of tree) 是根节点到叶节点的最长路径长

- 深度 (从根到当前节点，根节点深度0，根节点所在层数为1)
  - 对于任意节点n，节点n的深度为从根到n的唯一路径长
  - 一个节点的高度与深度的和为树高，所有节点高度与深度的和都为树高

- 层 level
  - 对于任意节点n，n所在的层数为n的深度 + 1，根节点在第1层
  - 树的总高度 = 树的总深度 = 树的总层数 - 1
  - 节点n的高度 + 节点n的深度 = 树的高度
  - 节点的深度 = 节点的所在层数 - 1

- 度 degree
  - 对于任意节点n，n含有的子树的个数称为节点n的度，
  - 最大的节点度称为树的度

Tree |Height|Depth|Level
-----|-----|-----|-----
 ROOT|  4  |  0  |  1
 node|  3  |  1  |  2
 node|  2  |  2  |  3
 node|  1  |  3  |  4
 LEAF|  0  |  4  |  5

- tree的存储结构
- 顺序存储
  - 就是用数组保存，但并不是任意的树都适合用数组。
  - 像满二叉树和完全二叉树就可以使用数组来存储，因为它们使用数组能做到紧凑排列而不浪费空间
  - 一般只有满二叉树和完全二叉树才用顺序存储方式，更加一般的树结构我们往往使用链式存储

- 链式存储（最普遍的存储方式）
  - 由于结点可能为空，所以会比较浪费空间

## 二叉树

- 二叉树 (Binary tree) 是每个节点最多只有两个分支（即不存在分支度大于2的节点）的树结构
  - 普通树节点的最大分支度没有限制，而二叉树节点的最大分支度为 2；
  - 普通树的节点个数至少为 1，而二叉树的节点个数可以为 0；
  - 普通树的节点无左、右次序之分，而二叉树的节点有左、右次序之分。

- 二叉树性质
  - 二叉树中第 i 层的结点数最多为2^(i-1)（i ≥ 1）
  - 高度为 k 的二叉树其结点总数最多为2^k－1（ k ≥ 1）
  - 若二叉树节点总数为t，则树的层数为 CEIL(log2(n+1))-1
  - 树的总高度 = 树的总深度 = 树的总层数 - 1

- 以数组存储的完全二叉树，索引i对应的父节点索引为(i-1)/2
  - 数组最后一个元素索引为i-1，所以其父节点索引为 (i-1-1)/2 = i/2 - 1

- 满二叉树 (Perfect Binary Tree)，又叫做完美二叉树
  - 这种树的特点是每一层上的节点数都是最大节点数

- 完全二叉树 (Complete Binary Tree)
  - 在一颗二叉树中，若除最后一层外的其余层都是满的，并且最后一层要么是满的，要么在右边缺少连续若干节点
- 如果一棵完全二叉树的任意一个非终端结点的元素都不小于其左儿子结点和右儿子结点（如果有的话） 的元素，则称此完全二叉树为**最大堆/大顶堆**。

## 二叉查找树 Binary Search Tree(BST)

- [树表的查找_二叉排序树定义](https://www.bilibili.com/video/BV1eR4y1E7SQ/)

- 特点
  - 左子树上所有结点的值均小于它的根结点的值
  - 右子树上所有结点的值均大于或等于它的根结点的值
  - 左、右子树也分别为二叉排序树
  - **没有键值相等的节点**

- 二分查找的时间复杂度是O(log(n))，最坏情况下的时间复杂度是O(n)（相当于顺序查找）

## AVL

- [树表的查找_平衡二叉树的定义](https://www.bilibili.com/video/BV1e34y1Z7jP/)

- 使用场景
  - avl适合查找多，插入少
  - 红黑树适合

- 平衡二叉树(balanced binary tree, 又称 AVL 树)
  - 一个二叉树每个节点的左右两个子树的高度差的绝对值不超过 1
  - 它的左子树和右子树都是平衡二叉树
- 平衡二叉树是对二叉搜索树(又称为二叉排序树)的一种改进。
  - 二叉搜索树有一个缺点就是，树的结构随意性很大，它只与节点的值和插入的顺序有关系，往往得到的是一个不平衡的二叉树。
  - 在最坏的情况下，可能得到的是一个单支二叉树，其高度和节点数相同，相当于一个单链表，对其正常的时间复杂度有O(log(n))变成了O(n)，从而丧失了二叉排序树的一些应该有的优点。

- self-balacing tree 平衡树的实现有多种
  - 2-3树
  - AVL
  - B-Tree
  - Red-black Tree
  - more: AA, Splay, Treap

## Red-black-Tree

- 特殊的BST

- [终结B站没人能讲清楚红黑树的历史(java): 从234到左旋右旋](https://www.bilibili.com/video/BV135411h7wJ/)

- [终于有人把红黑树讲明白了(java): 二叉树、avl、rbt](https://www.bilibili.com/video/BV1d64y1z7Uk?p=9)

- [红黑树原理源码讲解(java)](https://www.bilibili.com/video/BV1UJ411J7CU/?p=2)

## B-Tree

- [B树的引入，为什么会有B树，以设计磁盘文件系统的索引为例](https://www.bilibili.com/video/BV1mY4y1W7pS/)
- [B树的查找，B+树的引入](https://www.bilibili.com/video/BV1yB4y1v7Jy/)

- B-树是一种非二叉的查找树
- 一棵 m 阶的B-树
  - 所有的叶子结点都在相同的深度。
  - 树的根或者是一片叶子(一个节点的树), 或者其儿子数在 2 和 m 之间
  - 除根外，所有的非叶子结点的孩子数在 m/2 和 m 之间

## R-Tree

## Huffman Tree

- [哈夫曼树的引入](https://www.bilibili.com/video/BV1HW4y117Dj/)
  - 应用场景主要是编解码数据提交传输效率
  - 二叉树和B树主要用于索引

- 哈夫曼树(Huffman tree)
  - 给定n个权值作为n的叶子结点，构造一棵二叉树，若带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树
- 霍夫曼编码（Huffman编码）
  - Huffman编码是建立在Huffman树的基础上进行的，因此为了进行Huffman编码，必须先构建Huffman树；
  - 树的路径长度是每个叶节点到根节点的路径之和；带权路径长度是（每个叶节点的路径长度*wi）之和；
  - Huffman树是最小带权路径长度的二叉树；
# 其他树
- Trie 前缀树
- 一种有序树，用于保存关联数组，其中的键通常是字符串。
- 与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定
- 一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串
- Trie 树查询和插入时间复杂度都是 O(n)，是一种以空间换时间的方法
# ref
- [JS树形结构打印: 类似文件管理器，没有左子节点](https://www.jianshu.com/p/8a018d5ee1d9)
