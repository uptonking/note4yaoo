---
title: job-algs-tree
tags: [algorithms, job, tree]
created: '2021-09-21T19:41:38.307Z'
modified: '2021-09-21T19:45:13.231Z'
---

# job-algs-tree

# guide

# tree 基础
- tree特点
  - 每一个非根节点有且只有一个父节点
  - 除了根节点外，每个子节点可以分为多个不相交的子树
  - 树里面没有环路
- 高度
  - 对于任意节点n，节点n的高度为从n到叶节点的最长路径长，所有树叶的高度为 0。
  - 树的高度 (Height of tree) 是根节点到叶节点的最长路径长
- 深度
  - 对于任意节点n，节点n的深度为从根到n的唯一路径长
  - 一个节点的高度与深度的和为树高，所有节点高度与深度的和都为树高
- 对于任意节点n，n的层数为n的深度 + 1，根节点在第1层
  - 深度 = 层数 - 1
- 对于任意节点n，n含有的子树的个数称为节点n的度，最大的节点度称为树的度

- tree的存储结构
- 顺序存储就是用数组保存，但并不是任意的树都适合用数组。
  - 像满二叉树和完全二叉树就可以使用数组来存储，因为它们使用数组能做到紧凑排列而不浪费空间
  - 一般只有满二叉树和完全二叉树才用顺序存储方式，更加一般的树结构我们往往使用链式存储
- 以数组存储的完全二叉树，索引i对应的父节点索引为(i-1)/2
  - 数组最后一个元素索引为i-1，所以其父节点索引为 (i-1-1)/2 = i/2 - 1
# 树的经典问题

## 重建二叉树

> 根据一棵树的前序遍历与中序遍历构造二叉树。注意: 你可以假设树中没有重复的元素。

- 思路
  - 从前序遍历确定根结点
  - 在中序遍历找到根结点，将其分为左右子树
  - 根据中序遍历左右子树的个数，将前序遍历也分为对应的左右子树
  - 对左右子树的前序和中序再分别进行递归求解
  - 最后返回根节点
# 关于树的问题

# ref
- [JS 树形结构打印: 类似文件管理器，没有左子节点](https://www.jianshu.com/p/8a018d5ee1d9)
