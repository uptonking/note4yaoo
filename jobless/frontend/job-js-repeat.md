---
title: job-js-repeat
tags: [frontend, job, js, repeat]
created: '2021-09-21T19:54:16.072Z'
modified: '2021-10-10T09:31:09.831Z'
---

# job-js-repeat

# guide

- js语言特性与设计
- web基础
- 场景题
# faq

# 闭包以及闭包的应用场景

- 闭包的定义
  - 红宝书上对于闭包的定义：闭包是指有权访问另外一个函数作用域中的变量的函数。 
  - MDN对闭包的定义为：闭包是指那些能够访问自由变量的函数。这里的自由变量是外部函数作用域中的变量。
  - 在JS忍者秘籍(P90)中对闭包的定义：闭包允许函数访问并操作函数外部的变量

- 形成闭包的原因
  - 内部的函数存在外部作用域的引用就会导致闭包

- 闭包经典使用场景
  - 函数作为参数
  - return返回一个函数
  - IIFE（自执行函数）内访问外部变量
  - 循环赋值
  - 使用回调函数就是在使用闭包
  - 节流防抖
  - 柯里化实现
  - react hooks如返回值中的setState
    - [深入理解：React hooks是如何工作的](https://zhuanlan.zhihu.com/p/81528320)

- 一个函数和对其其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）
  - 存在自由变量的函数就是闭包
  - 「函数」和「函数内部能访问到的变量」的总和，就是一个闭包。
  - 闭包是指有权访问另一个作用域中变量的函数
- 内部的函数存在外部作用域的引用就会导致闭包

## [JS闭包经典使用场景和含闭包必刷题](https://juejin.cn/post/6937469222251560990)

- 函数的上级作用域在哪里创建创建的，上级作用域就是谁
  - 函数 foo() 是在全局下创建的，所以 a 的上级作用域就是 window 
- JS堆栈内存释放
  - 堆内存：存储引用类型值，对象类型就是键值对，函数就是代码字符串。
  - 堆内存释放：将引用类型的空间地址变量赋值成 null，或没有变量占用堆内存了浏览器就会释放掉这个地址
  - 栈内存：提供代码执行的环境和存储基本类型值。
  - 栈内存释放：一般当函数执行完后函数的私有作用域就会被释放掉。
- 但栈内存的释放也有特殊情况：
  - ① 函数执行完，但是函数的私有作用域内有内容被栈外的变量还在使用的，栈内存就不能释放里面的基本值也就不会被释放。
  - ② 全局下的栈内存只有页面被关闭的时候才会被释放

- 闭包变量存储的位置
  - 闭包中的变量存储的位置是堆内存。
  - 假如闭包中的变量存储在栈内存中，那么栈的回收会把处于栈顶的变量自动回收。所以闭包中的变量如果处于栈中那么变量被销毁后，闭包中的变量就没有了。所以闭包引用的变量是出于堆内存中的。

- 闭包的作用
  - 保护函数的私有变量不受外部的干扰。形成不销毁的栈内存。
  - 把一些函数内的值保存下来。闭包可以实现方法和属性的私有化

- 使用闭包需要注意什么
  - 检查内存泄露
    - performance 面板 和 memory 面板可以找到泄露的现象和位置

## [说说你对闭包的理解？闭包使用场景 ](https://github.com/febobo/web-interview/issues/57)

- 任何闭包的使用场景都离不开这两点
  - 创建私有变量
  - 延长变量的生命周期

- 一般函数的词法环境在函数返回后就被销毁，
  - 但是闭包会保存对创建时所在词法环境的引用，即便创建时所在的执行上下文被销毁，但创建时所在词法环境依然存在，以达到延长变量的生命周期的目的

- js闭包的本质源自两点，词法作用域和函数当作值传递
  - 词法作用域，就是按照代码书写时的样子，内部函数可以访问函数外面的变量
    - 引擎通过数据结构和算法表示一个函数，使得在代码解释执行时按照词法作用域的规则，可以访问外围的变量，这些变量就登记在相应的数据结构中。
  - 函数当作值传递，由于内部函数作为值返回出去，这些值得以保存下来。而且无法直接访问，必须通过返回的函数。 

- 作用域和词法作用域
  - 作用域就是查找变量(去哪儿找，怎么找)的一套规则。词法作用域在你写代码的时候就确定了。JavaScript是基于词法作用域的语言，通过变量定义的位置就能知道变量的作用域。
- 作用域链
  - 当某个函数第一次被调用时，会创建一个执行环境及相应的作用域链，并把作用域链赋值给一个特殊的内部属性 [[Scope]] 。然后，使用 this、arguments 和其他命名参数的值来初始化函数的活动对象。但在作用域中，外部函数的活动对象始终处于第二位，外部函数的外部函数的活动对象处于第三位，... 直至作用作用域链终点的全局执行环境。

## 闭包输出题

```JS
var data = [];

for (var i = 0; i < 3; i++) {
  data[i] = function() {
    console.log(i);
  };
}

data[0]();
data[1]();
data[2]()
/* 输出
    3
    3
    3
    这里的 i 是全局下的 i，共用一个作用域，当函数被执行的时候这时的 i=3，导致输出的结构都是3
/

var data = [];

// let 具有块级作用域，形成的3个私有作用域都是互不干扰的。
for (let i = 0; i < 3; i++) {
  data[i] = function () {
    console.log(i);
  };
}

data[0]();
data[1]();
data[2]()

```
