---
title: job-fe-faq
tags: [engineering, faq, frontend, job]
created: 2021-09-21T19:48:12.024Z
modified: 2021-10-10T09:18:13.931Z
---

# job-fe-faq

# guide

# 双向绑定 vs 单向绑定
- [说说你对双向绑定的理解?](https://zhuanlan.zhihu.com/p/321367623)
- 单向绑定非常简单，就是把Model绑定到View，当我们用JavaScript代码更新Model时，View就会自动更新
- 双向绑定，是在单向绑定的基础，用户更新了View，Model的数据也自动被更新了
  - 数据变化后更新视图
  - 视图变化后更新数据
- 监听器（Observer）：对所有数据的属性进行监听
- 解析器（Compiler）：对每个元素节点的指令进行扫描跟解析, 根据指令模板替换数据, 以及绑定相应的更新函数
- 给出了实现示例

- [为什么react不实现双向绑定](https://www.zhihu.com/question/300849926/answers)
- 双向或者单向， 只是实现某些功能的方式或者理念，React完全可以以双向的方式去处理组件之间的交互逻辑

- 在构建一些复杂的交互应用，双向绑定就变得复杂
  - 有些数据只在内存操作并不想在视图中展示怎么办？那么就要写更多脱离双向绑定的代码，做个数据中间层做转化
  - 那么问题来了，部分数据要涉及到视图更新，但是部分不涉及，就又会写很多判断去处理，这时候代码就会很乱业务不清晰
  - 而数据单向流的优势就出现了，react只需要setState对应的数据即可，无需做判断。

- [单向数据绑定和双向数据绑定的优缺点，适合什么场景？](https://www.zhihu.com/question/49964363/answer/136022879)
- 单向绑定的优点是相应的可以带来单向数据流，这样做的好处是所有状态变化都可以被记录、跟踪，状态变化通过手动调用通知，源头易追溯，没有“暗箱操作”。
  - 同时组件数据只有唯一的入口和出口，使得程序更直观更容易理解，有利于应用的可维护性。
  - 缺点则是代码量会相应的上升，数据的流转过程变长，从而出现很多类似的样板代码。
  - 同时由于对应用状态独立管理的严格要求(单一的全局store)，在处理局部状态较多的场景时(如用户输入交互较多的“富表单型”应用)，会显得啰嗦及繁琐。
- 双向绑定的优缺点就是单向绑定的镜像了。
  - 优点是在表单交互较多的场景下，会简化大量业务无关的代码。
  - 缺点就是由于都是“暗箱操作”，我们无法追踪局部状态的变化
- 我们可以在合适的场景下使用合适的手段。比如在 UI控件 中(通常是类表单操作)，我会使用双向的方式绑定数据；而其他场景则统一采用 单向 + inline event
# csr vs ssr
- ssr
  - 浏览器向后端请求页面
  - 后端服务器会计算所需的业务数据后将结果填充在页面的对应区域，再将页面响应给前端
  - 前端直接对收到的html进行解析其中已经包含页面的样式，也包含完整的数据信息

- ssr-pros
  - 首屏加载时间短
  - 易于SEO

- ssr-cons
  - 前后端耦合不利于开发维护
  - 加大服务端压力

- csr
  - 浏览器向后端请求页面
  - 后端响应一个静态的html页面，不对页面进行业务数据的拼接，该html上有js脚本
  - 浏览器下载、解析、执行js文件，通过操作 dom 对 html 内容进行填充修改
- 目前的SPA应用不再是一个页面，本质是一个集路由、数据、页面（组件）为一体的程序，在首次请求经服务端获取整个应用后，接下来的路由都由前端控制，前端以路由为中心枢纽控制一系列页面（组件）的渲染加载和数据交互

- csr-pros
  - 前后端分离，更维护
  - 易实现本地化、离线应用，用户体验更好
  - 节省服务器资源

- csr-cons
  - 首屏慢
  - seo难

- 前端框架方向
  - 前后端一体化框架，自动生成api层
  - streaming ssr
# [安全相关 XSS](https://juejin.cn/post/6844904179182354439)
- XSS Cross Site Script
  - XSS攻击，通常是指攻击者通过 “HTML注入”篡改了网页，插入了恶意的脚本，从而在用户浏览网页时，对用户的浏览器进行控制或者获取用户的敏感信息（Cookie, SessionID等）的一种攻击方式。
  - 页面被注入了恶意JavaScript脚本，浏览器无法判断区分这些脚本是被恶意注入的，还是正常的页面内容
- 可以
  - 窃取cookie信息
  - 监听用户行为
  - 修改DOM 伪造假的登陆窗口
  - 在页面内生成浮窗广告

- 防御XSS的方法
  - 利用CSP(Content Security Policy) 即内容安全策略，是一种可信白名单机制
  - 防御 DOM Based XSS
    - 从JavaScript输出到HTML页面，相当于一次 XSS输出的过程
    - 会触发 DOM Based XSS的地方有很多，比如 innerHTML/document.write/页面中所有的input框/XMLHttpRequest返回的数据 
    - 一定要避免在字符串中拼接不可信的数据
  - 使用HttpOnly属性来防止直接通过 document.cookie 来获取 cookie。
    - HttpOnly 并非阻止 XSS 攻击，而是能阻止 XSS 攻击后的 Cookie 劫持攻击。
  - 输入和输出的检查
    - 永远不要相信用户的输入
    - 可以在服务端配置浏览器哪些外部资源可以加载和执行

- 反射型XSS
  - 恶意脚本作为网络请求的一部分。
  - `http://127.0.0.1:3000?userName=<script>alert("反射型 XSS 攻击")</script>` 恶意脚本在url中
  - 用户将一段含有恶意代码的请求提交给服务器，服务器在接收到请求时，又将恶意代码反射给浏览器端，这就是反射型XSS攻击
  - Web 服务器不会存储反射型 XSS 攻击的恶意脚本

- 存储型XSS
  - 存储型会把用户输入的数据“存储”在服务器。
  - 常见的一个场景就是，攻击者在社区或论坛写下一篇包含恶意 JavaScript代码的博客文章或评论，文章或评论发表后，所有访问该博客文章或评论的用户，都会在他们的浏览器中执行这段恶意的JavaScript代码。
  - 首先攻击者利用站点漏洞将一段恶意JavaScript代码提交到网站数据库中
  - 然后用户向网站请求包含了恶意 JavaScript脚本的页面
  - 当用户浏览该页面的时候，恶意脚本就会将用户的cookie信息等数据上传到服务器

- 基于DOM(DOM based XSS)
  - 通过恶意脚本修改页面的DOM节点，是发生在前端的攻击
  - 攻击者构造出特殊的URL，其中包含恶意代码
  - 用户打开带有恶意代码的URL
  - 用户浏览器接受到响应后执行解析，前端JavaScript取出URL中的恶意代码并执行
  - 恶意代码窃取用户数据并发送到攻击者的网站，冒充用户行为，调用目标网站接口执行攻击者指定的操作。
# [安全相关 CSRF](https://juejin.cn/post/6844904180918779918)
- 跨站请求伪造（Cross Site Request Forgery），是指攻击者诱导用户打开伪造的网站，在伪造网站中，利用用户的登陆状态发起的跨站请求。
  - CSRF攻击就是利用了用户的登陆状态，并通过第三方的站点来做一个坏事。
- 要完成一次CSRF攻击, 受害者依次完成两个步骤:
  - 登录受信任网站A，并在本地生成Cookie
  - 在不登出A的情况，访问危险网站B
  - 在a.com登陆后获得cookie, 然后有个支付的页面，支付页面有个诱导点击的按钮或者图片，第三方网站域名为 b.com，中的页面请求 a.com的接口，b.com 其实拿不到cookie，请求 a.com会把Cookie自动带上（因为Cookie种在 a.com域下）

- CSRF攻击
  - 自动发起Get请求
  - 自动发起POST请求
  - 引导用户点击链接

- CSRF防御
  - 利用cookie的SameSite
  - 验证请求的来源点，通过HTTP请求头中的 Referer和Origin属性。
  - 最开始浏览器向服务器发起请求时，服务器生成一个CSRF Token，浏览器之后再发起请求的时候，需要带上页面中的 CSRF Token
# target 和 currentTarget 的区别
- target在事件流的目标阶段；
  - currentTarget在事件流的捕获，目标及冒泡阶段。
  - 只有当事件流处在目标阶段的时候，两个的指向才是一样的，
- 而当处于捕获和冒泡阶段的时候，target指向被点击的对象而currentTarget指向当前事件活动的对象（一般为父级）。
