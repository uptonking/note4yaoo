---
title: job-fe-http-network
tags: [http, job, network]
created: '2021-10-10T09:20:12.931Z'
modified: '2021-10-10T09:20:55.154Z'
---

# job-fe-http-network

# guide

# http 三次握手，四次挥手，为什么是三次和四次

- 三次握手
  - 发送端首先发送一个带SYN标志的数据包给对方
  - 接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息
  - 最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。
- 若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。



- 为什么是三次？
  - 建立一个TCP连接时，需要客户端和服务器总共发出3个包，
  - 三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常。指定自己的初始化序列号为后面的可靠性传送做准备。
  - 第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力。服务端的接收能力是正常的。
  - 第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收。发送能力是正常的。
  - 第三次握手：客户端发包，服务端收到了。
  - 这样服务端就能得出结论：客户端的接收。发送能力正常，服务器自己的发送、接收能力也正常。
- 不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源


- 四次挥手
  - 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方
  - 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。
  - 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，
  - 第四次挥手：主动关闭方收到 FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。


- 挥手为什么是四次?
  关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。
  只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。

# GET vs POST
- 参数
  - GET一般放在URL中，因此不安全，POST放在请求体中，更适合传输敏感信息。
- TCP 
  - GET请求会把浏览器会把http header和data一次性发出去，
  - 而POST会分成两个TCP数据包，首先发Header部分，如果服务器响应100(continue)， 然后发body部分。(火狐浏览器除外，它的 POST 请求只发一个 TCP 包)
- 缓存
  - GET请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会
- 编码
  - GET只能进行URL编码，只能接收 ASCII 字符，而 POST 没有限制。
- 幂等
  - GET是幂等的，而POST不是。(幂等表示执行相同的操作，结果也是相同的)
# [HTTP知识点整理](https://github.com/funnycoderstar/blog/issues/127)


- HTTP状态码
  - 1xx (信息性状态码) 接受的请求正在处理
  - 2xx 成功 请求正常处理完毕
  - 3xx 重定向 需要进行附加操作已完成请求
  - 4xx 客户端错误 服务器无法处理请求
  - 5xx 服务器错误 服务器处理请求错误


## http1.0 和HTTP1.1的一些区别
- 长连接
  - 1.1中默认开启Connection： keep-alive，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟
- 缓存处理
  - http1.0 主要使用header中的Exprires， If-Modified-Since来做为缓存判断的标准
  - HTTP1.1 Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。
- 带宽优化
  - HTTP1.0中，存在一些浪费带宽的现象，不支持断点续传功能
  - 1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content）
- Host头处理
  - 在HTTP/1.0中认为每台服务器都有唯一的IP地址，但随着虚拟主机技术的发展，多个主机共享一个IP地址愈发普遍，
  - HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会400错误

# 301 vs 302

- 301 Moved Permanently
- 302 Found but changed temporarily 临时重定向
# websocket

- HTTP协议通信只能由客户端发送，实现想消息通知的这种，我们只能使用“轮询”：每隔一段时间，就发出一个后端请求，询问有没有新的消息更新。
- WebSocket 和 HTTP 一样，同属于应用层协议。
  - 它最重要的用途是实现了客户端与服务端之间的全双工通信，当服务端数据变化时，可以第一时间通知到客户端。

- 与http协议不同的地方
  - http只能由客户端发起，而webSocket是双向的。
  - 没有同源限制，可以跨域共享资源
  - webSocket传输的数据包相对于http而言很小，很适合移动端使用

# tcp vs udp

- 可靠性
  - tcp消息确定要收到，发送失败，会重新传输
  - udp消息不确定收到，可能丢包
- 有序性
  - tcp每个数据包都有编号，udp无序
# 缓存（强缓存），如何设置缓存

## [深入浅出浏览器缓存机制](https://juejin.cn/post/6844903757872889870)

- 一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷。
- 对于一个数据请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤
  - 浏览器缓存可以帮助我们在第一和第三步骤中优化性能

- 从缓存位置上来说分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络。

### Service Worker

- Service Worker是运行在浏览器后台的独立线程，一般可以用来实现缓存功能
  - 使用 Service Worker的话，传输协议必须为 HTTPS
  - 因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。
  - Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。
- 当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch 函数获取数据。
  - 也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。
  - 但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。

### Memory Cache

- 内存中的缓存，主要包含的是当前中页面中已经抓取到的资源, 例如页面上已经下载的样式、脚本、图片等。
- 读取内存中的数据肯定比磁盘快, 内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放
- 一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。
- 内存缓存中有一块重要的缓存资源是preloader相关指令（例如`<link rel="prefetch">`）下载的资源。
  - 总所周知preloader的相关指令已经是页面优化的常见手段之一，它可以一边解析js/css文件，一边网络请求下一个资源。
  - 内存缓存在缓存资源时并不关心返回资源的HTTP缓存头Cache-Control是什么值，同时资源的匹配也并非仅仅是对URL做匹配，还可能会对Content-Type，CORS等其他特征做校验。

### Disk Cache

- 会根据 HTTP Header 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求

### Push Cache

- 当以上三种缓存都没有命中时，它才会被使用。
  - 它只在会话（Session）中存在，一旦会话结束就被释放，
  - 并且缓存时间也很短暂，在Chrome浏览器中只有5分钟左右，同时它也并非严格执行HTTP头中的缓存指令。

- 如果以上四种缓存都没有命中的话，那么只能发起请求来获取资源了。

### 强缓存

- 通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置 HTTP Header 来实现的。

- 浏览器第一次向服务器发起该请求后拿到请求结果后，浏览器对于缓存的处理是根据第一次请求资源时返回的响应头来确定的
  - 浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识
  - 浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中

- 强缓存
  - 不会向服务器发送请求，直接从缓存中读取资源，
  - 在chrome控制台的Network选项中可以看到该请求返回200的状态码，并且Size显示from disk cache或from memory cache。
  - 强缓存可以通过设置两种 HTTP Header 实现：`Expires` 和 `Cache-Control`。

- Expires
  - 缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。
  - 也就是说，Expires=max-age + 请求时间，需要和Last-modified结合使用。
  - Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。
  - Expires 是 HTTP/1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效。

- Cache-Control
  - 在HTTP/1.1中，Cache-Control:max-age=300，代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。

- Expires和Cache-Control两者对比
  - 这两者差别不大，区别就在于 Expires 是http1.0的产物，Cache-Control是http1.1的产物，两者同时存在的话，Cache-Control优先级高于Expires
  - Expires其实是过时的产物，现阶段它的存在只是一种兼容性的写法。
- 强缓存判断是否缓存的依据来自于是否超出某个时间或者某个时间段，而不关心服务器端文件是否已经更新，这可能会导致加载文件不是服务器端最新的内容，
  - 那我们如何获知服务器端内容是否已经发生了更新呢？此时我们需要用到协商缓存策略。

### 协商缓存

- 协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况
  - 协商缓存生效，返回304和Not Modified
  - 协商缓存失效，返回200和请求结果
- 协商缓存可以通过设置两种 HTTP Header 实现：Last-Modified 和 ETag 。

- 浏览器在第一次访问资源时，服务器返回资源的同时，在response header中添加 Last-Modified的header，是这个资源在服务器上的最后修改时间，浏览器接收后缓存文件和header；
  - 浏览器下一次请求这个资源，浏览器检测到有 Last-Modified这个header，于是添加`If-Modified-Since`这个header，值就是Last-Modified中的值；
  - 服务器再次收到这个资源请求，会根据 If-Modified-Since 中的值与服务器中这个资源的最后修改时间对比，
  - 如果没有变化，返回304和空的响应体，直接从缓存读取，
  - 如果If-Modified-Since的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和200
- Last-Modified 存在一些弊端：
  - Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源
- 既然根据文件修改时间来决定是否缓存尚有不足，能否可以直接根据文件内容是否修改来决定缓存策略？所以在 HTTP / 1.1 出现了 ETag 和If-None-Match

- Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，只要资源有变化，Etag就会重新生成。
  - 浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request header里的If-None-Match里，服务器只需要比较客户端传来的If-None-Match跟自己服务器上该资源的ETag是否一致，就能很好地判断资源相对客户端而言是否被修改过了。
  - 如果服务器发现ETag匹配不上，那么直接以常规GET 200回包形式将新的资源（当然也包括了新的ETag）发给客户端；
  - 如果ETag是一致的，则直接返回304知会客户端直接使用本地缓存即可。

- 在精确度上，Etag要优于Last-Modified。
  - 在性能上，Etag要逊于Last-Modified
  - 在优先级上，服务器校验优先考虑Etag

### 缓存机制

- 强制缓存优先于协商缓存进行，
  - 若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，
  - 协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回200，重新返回资源和缓存标识，再存入浏览器缓存中；生效则返回304，继续使用缓存

- 如果什么缓存策略都没设置，那么浏览器会怎么处理？
- 浏览器会采用一个启发式的算法，通常会取响应头中的 Date 减去 Last-Modified 值的 10% 作为缓存时间。

### 实际场景应用缓存策略

- 频繁变动的资源
  - Cache-Control: no-cache
  - 这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。

- 不常变化的资源
  - Cache-Control: max-age=31536000(一年)
  - 请求相同的 URL 会命中强制缓存。而为了解决更新的问题，就需要在文件名(或者路径)中添加 hash， 版本号等动态字符

- 用户行为对浏览器缓存的影响
  - 打开网页，地址栏输入地址： 查找 disk cache 中是否有匹配。如有则使用；如没有则发送网络请求
  - 普通刷新 (F5)：因为 TAB 并没有关闭，因此 memory cache 是可用的，会被优先使用(如果匹配的话)。其次才是 disk cache
  - 强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有 Cache-control: no-cache(为了兼容，还带了 Pragma: no-cache), 服务器直接返回 200 和最新内容。

- ref
  - [深入浅出浏览器缓存机制](https://juejin.cn/post/6844903757872889870)
  - [图解 HTTP 缓存](https://juejin.cn/post/6844904153043435533)
# 跨域相关
- 浏览器规定，静态资源请求和提交表单不受同源政策的限制，ajax请求受同源策略限制。

- 最简单的解决跨域方法是JSONP：
  - 只支持GET，不支持POST请求代理。
  - 原理：浏览器只对XHR(XMLHttpRequest)请求有同源请求限制，而对script标签src属性、link标签ref属性和img标签src属性没有这这种限制
  - 当向第三方站点请求时，我们可以将此请求放在`<script>`标签的src属性里，这就如同我们请求一个普通的JS脚本

- 在使用script标签中有跨域访问资源能力有例如：src link img a href.

## jsonp

- 利用script标签的src属性能够发起跨域请求的原理来实现
  - 但是会看到浏览器报错，这时因为`data.json`中的内容并不符合JavaScript代码规范。
  - 需要修改data.json内容为类似 `callback({ username: "mi1k7ea", password: "secret" })`，作为js脚本
  - jsonp的实现需要服务端的配合，典型的流程是服务器接收到callback参数如cb1，然后返回 `cb1({})`的js脚本会在浏览器客户端执行
- `<script>`标签默认，如果没有定义`type`属性，脚本会被视作JavaScript
  - 支持的MIME类型包括text/javascript, text/ecmascript, application/javascript, 和application/ecmascript。

- callback自定义导致的XSS
  - `callback=hello<script>alert(0)</script>` 可以篡改
- JSONP劫持
  - 其实和CSRF的攻击是类似的，只不过CSRF是提交表单请求，而JSONP劫持是将请求JSONP端点获取到的JSONP数据发往攻击者服务器中、实现获取JSONP敏感信息。
  - 因此，JSONP劫持的前提和CSRF是一样的，当服务端没有校验请求来源，如未严格校验Referrer或未存在token机制等，都会导致JSONP劫持的产生。

- ref
  - [JSONP跨域漏洞总结](https://www.mi1k7ea.com/2019/08/20/JSONP%E8%B7%A8%E5%9F%9F%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/)

## CORS

- CORS是一个W3C标准，它允许浏览器向跨源服务器，发出XMLHttpRequest请求 
  - CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能
  - 实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。
  - 在 HTTP 响应中为开放的数据添加特殊的 CORS 头：
  - Access-control-Allow-Origin: * // 对任意源开放
  - ccess-Control-Allow-Methods: GET, POST, PUT 
- 浏览器将CORS请求分成两类：简单请求和非简单请求，两种都会在头信息之中，增加一个Origin字段
  - 对于简单请求，浏览器直接发出CORS请求。
  - 非简单请求的CORS请求，会在正式通信之前，增加一次Options方法HTTP查询请求，称为"预检"请求（preflight）。
  - 浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。

- 解决跨域除了CORS标准方法外，还可以通过代理解决。
  - nodejs和nginx都可以反向代理，解决跨域问题。
  - 原理是，把页面资源放到HTTP服务器，页面的接口请求都使用相对地址。
  - 这样网站所有请求都会走到HTTP服务器，HTTP服务器根据请求路径（如路由模块）来区别处理，
  - 若请求静态资源就直接返回，如果是接口请求则由HTTP服务器代理发起请求，拿到结果后再返回给页面接口，实现跨域。

- ref
  - [XMLHttpRequest-->跨域限制和XSS-->代理](https://segmentfault.com/a/1190000022115085)
# https

## [深入理解HTTPS工作原理](https://juejin.cn/post/6844903830916694030)

- HTTPS是在HTTP上建立SSL加密层，对传输数据进行加密，是HTTP协议的安全版

- HTTPS主要作用
  - 对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全
  - 对网站服务器进行真实身份认证

- HTTP协议存在的哪些问题：
  - 数据传输使用明文（不加密），内容可能被窃取
  - 无法证明报文的完整性，所以可能遭篡改
  - 不验证通信方的身份，因此有可能遭遇伪装

- HTTPS协议
  - HTTPS并非是应用层的一种新协议。只是HTTP通信接口部分用SSL和TLS协议代替而已。
  - 通常，HTTP直接和TCP通信。当使用SSL时，则演变成先和SSL通信，再由SSL和TCP通信了
- 数据隐私性：内容经过对称加密，每个连接生成一个唯一的加密密钥
  - 对称密钥的好处是解密的效率比较快，使用非对称密钥的好处是可以使得传输的内容不能被破解
  - 具体做法是：发送密文的一方使用对方的公钥进行加密处理“对称的密钥”，然后对方用自己的私钥解密拿到“对称的密钥”，这样可以确保交换的密钥是安全的前提下，使用对称加密方式进行通信
  - HTTPS采用对称加密和非对称加密两者并用的混合加密机制。
- 数据完整性：内容传输经过完整性校验
  - 将一段文本先用Hash函数生成消息摘要，然后用发送者的私钥加密生成数字签名，与原文文一起传送给接收者
  - 接收者只有用发送者的公钥才能解密被加密的摘要信息
  - 此时就需要引入了证书颁发机构（Certificate Authority，简称CA），CA对公钥（和其他信息）数字签名后生成证书。
- 身份认证：第三方无法伪造服务端（客户端）身份
  - 数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场上。

- HTTPS工作流程
  1. Client发起一个HTTPS（比如https://juejin.cn/user/4283353031252967）的请求，根据RFC2818的规定，Client知道需要连接Server的443（默认）端口。
  2. Server把事先配置好的公钥证书（public key certificate）返回给客户端。
  3. Client验证公钥证书：比如是否在有效期内，证书的用途是不是匹配Client请求的站点，是不是在CRL吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书（操作系统内置的Root证书或者Client内置的Root证书）。如果验证通过则继续，不通过则显示警告信息。
  4. Client使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密这个对称密钥，发给Server。
  5. Server使用自己的私钥（private key）解密这个消息，得到对称密钥。至此，Client和Server双方都持有了相同的对称密钥。
  6. Server使用对称密钥加密“明文内容A”，发送给Client。
  7. Client使用对称密钥解密响应的密文，得到“明文内容A”。
  8. Client再次发起HTTPS的请求，使用对称密钥加密请求的“明文内容B”，然后Server使用对称密钥解密密文，得到“明文内容B”。


- HTTP 与 HTTPS 的区别
  - HTTPS比HTTP更加安全
  - HTTPS标准端口443，HTTP标准端口80;
  - HTTPS基于传输层，HTTP基于应用层;
  - HTTPS需要用到SSL证书，而HTTP不用;
# HTTP2的性能优化方面，真的优化很多么

> 多路复用、头部压缩、服务端推送

- http 1.1的问题
  - 请求阻塞：TCP连接上只能发送一个请求，前面的请求未完成前，后续的请求都在排队等待。
  - 多个tcp连接：1.1版本并发请求依赖于多个TCP连接，建立TCP连接成本很高，还会存在慢启动的问题。
  - 头部冗余，采用文本格式：HTTP/1. X版本是采用文本格式，首部未压缩，而且每一个请求都会带上cookie、user-agent等完全相同的首部。
  - 客户端需要主动请求

- HTTP2性能提升的核心就在于二进制分帧层。
  - HTTP2是二进制协议，他采用二进制格式传输数据而不是1.x的文本格式。
  - 1.1响应是文本格式，而2.0把响应划分成了两个帧，HEADERS（首部）和DATA（消息负载） 是帧的类型

- 重要概念
  - 流（Stream）
    - 已建立的TCP连接上的双向字节流，可以承载一个或多个消息。
    - 一个TCP连接上可以有任意数量的流。
  - 消息（Message）
    - 特定消息的帧在同一个流上发送，这意味着一个HTTP请求或响应只能在一个流上发送。
  - 帧（Frame）
    - 通信的基本单位。
    - 一个完整的HTTP请求或响应，由一个或多个帧组成。

- 1.1的线头阻塞和多个TCP连接的问题，HTTP2的多路复用完美解决
  - HTTP2让所有的通信都在一个TCP连接上完成，真正实现了请求的并发。
  - HTTP2建立一个TCP连接，一个连接上面可以有任意多个流（stream），消息分割成一个或多个帧在流里面传输。
  - 帧传输过去以后，再进行重组，形成一个完整的请求或响应。这使得所有的请求或响应都无法阻塞。

- HTTP2采用HPACK压缩格式来压缩首部。

- 服务端推送
  - 实现原理就是客户端发出页面请求时，服务器端能够分析这个页面所依赖的其他资源，主动推送到客户端的缓存，
  - 当客户端收到原始网页的请求时，它需要的资源已经位于缓存。

- ref
  - [你了解HTTP2.0吗？](https://juejin.cn/post/6844903734670000142)
