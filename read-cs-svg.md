---
title: read-cs-svg
tags: [book, cs, svg]
created: '2020-08-03T09:38:20.763Z'
modified: '2020-08-03T09:39:19.995Z'
---

# read-cs-svg

## SVG动画 

- [SVG动画_Sarah Drasner_2017](https://www.zhihu.com/pub/book/119896387)

- svg优点
  - 方便实现数据可视化
  - 响应式，可缩放
  - 性能较高：矢量图体积比位图小
  - 可操作的DOM结构
- SVG 的 viewBox 是一个非常强大的属性，因为是它真正地允许 SVG 画布无限延伸，并同时控制和精确定义 SVG 的可视空间。
  - 按照 x、y、width 和 height 的顺序，viewBox 有 4 个参数需要设置。
  - 可以发现，viewBox 的值并没有带单位，这是因为 SVG 可视空间并不是基于像素来设定的，而是一个可任意延展的空间，这样就可以适应许多不同的尺寸。
- 使用 CSS 控制一个元素的尺寸，并且将尺寸都保存在一个 CSS 文件中，这种做法是较好且简单的。
  - 但是，我通常不会在 CSS 内定义 SVG 的 width 和 height，因为担心 CSS 文件不能被正常加载。
  - 如果同时也没有在 SVG 中设置 width 和 height 属性，那么 SVG 就会继承父级的宽高，这样就完美地达到响应适配的效果了。
  - 介于这个原因，当需要设定宽高的时候，可以在 SVG 中加上行列属性作为保障，因为 CSS 属性会覆盖行列属性的值。而如果 CSS 属性没有被正确加载，则会取用行列属性
- 你可以完全手写 SVG，也可以使用 JS 库来绘制 SVG，例如 D3
  - 当你想设计和创建一个 SVG 时应该选用例如 Adobe Illustrator（AI）、Sketch 或者 Inkscape 这样的矢量图处理工具。
  - 通过使用这些工具，每一图层中的图片会以 g 标签的形式被导出，并将图层名赋值给 g 标签的 id。
- 当使用 AI 的时候，应该确保使用「文件 → 导出 → SVG」这样的步骤来导出 SVG，而不是直接选择「另存为」
  - 这种方式导出 SVG 会比直接通过「另存为」命令生成的没有进行优化的 SVG 在体积上更小，且绘图信息更精确。
  - AI 导出的 SVG 中有一些信息是十分有用的，但有些是可以丢弃的，例如 AI 导出的 SVG 中夹带的注释部分。
  - 版本信息和图层信息也不需要，当用于线上环境的时候，这些信息通常没有什么用，增加了体积还不便于传输，应尽量让 SVG 文件体积更小。
- 如果使用的是行内的 SVG，同样也可以去掉关于 XML 的定义。强调一下，在此书内自始至终都会使用行内的 SVG，这样能更好地控制 SVG 动画，减小出错的风险。
- 也可以优化 path，AI 导出的 SVG 中的 path 数据会夹带许多浮点小数，通常情况下这些数是可以被四舍五入的。同时导出的 g 标签也会扰乱你的代码 
- 其实没必要手动去掉那些不必要的信息，因为开源社区提供了很多用于优化 SVG 的工具，它们可以帮助你减少代码体积。
- 这些工具具有如下一些功能：自动四舍五入过长的数字，合并路径数据，移除非必要的图层等。
  - SVGO: 基于nde的svg优化工具，提供了SVGO-GUI
  - SVGOMG: 在线优化工具，底层是SVGO
  - SVGEditor: 在线编辑svg
- SVG 也能通过 CSS 进行动画制作
  - 如果使用 SVG，相对于 CSS 来说，绘制一张插画较为简单，而且更容易缩放，添加的动画也是响应式的，不用兼容各种不同宽高的屏幕。
- 当前 SVG DOM 只在某些浏览器中存在硬件加速功能
  - 例如，只有 Firefox 支持 SVG 硬件加速，而 Chrome 不支持，
  - 但是，即使浏览器对 SVG 存在硬件加速等优化，你仍然应该用 transforms 进行 SVG DOM 的移动，千万别用 margin 或者其他 CSS 位移属性（涉及浏览器的重构和重排）。
- 在 Illustrator 中使用模板绘制
- 在 SVG 编辑器或图纸中逐帧绘制并且使用 Gruntiocon 生成 Sprite
- 如果将一个普通 SVG 上的 width 和 height 属性移除，将会看到一些有趣的事情。SVG 会填满视窗的 width，并且保持里面 DOM 的高宽比不变。
  - 如果我们在 SVG 放大或缩小之前使用 CSS 关键帧或者 JavaScript 代码移动 SVG 元素，比如 circle 或者 path，那么这些变化同样会在图形中被缩放。
  - 这意味着如果通过百分数、CSS 的 flexbox 属性或者其他技术去缩放一个复杂的 SVG，那么你的动画也会被相应缩放。
  - 你不需要为了手机或者其他尺寸的设备调整任何代码，只需要关注如何一次写出正确的代码即可。
  - 完整的动画应该能被完美地缩放
- 当得到了上述 Sprite 图后，就可以使用 SVGOMG 的 Web 模式的 GUI 去优化该图，检查是否有失真，清除不必要的 ID 的选项，合并无用的分组。
  - 然后，可以在需要的时候，将 ID 改为类名，清除一些导出文件中没用的设计。
  - 我一般手动或者通过查找替换的方式完成这件事，不过完成这件事的方法有很多。
  - 优化后的 SVG 是直接内嵌在 HTML 里的，而不是像之前的技术那样，使用背景图的 URL 属性。
  - 现在，我们将 SVG 隐藏，然后以移动端优先的方式进行展示
  - 当水平调整浏览器窗口的大小时，SVG 视窗会进行相应变化去展示想要展示的那一部分。
  - 现在，我们的代码已经写好了并且准备开始实施动画。
- 当从图形编辑器中导出 Sprite 图时，其中每一个元素都有独一无二的 ID。对于重复的元素，我更倾向于使用类名
  - 一些元素可以共享一个常见动画，比如点和星星。
  - 我们可以复用这些声明，只要根据需要调整延迟时间。
  - 将延迟时间设置为负值，这样可以在开始的时候就立即出现动画，即使这些元素动画是交叉的
- 动画有很多方式来帮助数据可视化
  - 过滤
  - 牌序
  - 时间序列的变化
  - 透明度的变化
- 用D3来做动画
  - d3-interpolate-path可以用来创建漂亮的动画路径
- web动画技术比较
  - 之前的内容仅涵盖CSS实现的动画，从这一章开始转向js实现的动画
  - 基于我长期使用的经验，这里给出一个简短的建议：GreenSock，
    - 它处理了 SVG 的一些跨浏览器问题，并且其实现考虑了各种动画场景，
    - 因此 GreenSock 会成为我最常用于生产环境的动画技术。
- CSS动画
  - 优点
    - 无外部依赖
    - 性能良好，easing也可以使用变量
    - 可以使用js监听动画相关事件，如onAnimationEnd
    - 沿路径运动这样的效果将会在 CSS 中被支持，这样的能力对于实现真实的运动动画是很有必要的，
      - 而由于 SMIL 渐渐被抛弃，这一点已经变得越发重要了。
  - 缺点
    - bezier缓动效果在某些情况下会受限制
      - 由于 Bézier 缓动只能通过两个控制点来控制曲线，无法产生复杂的物理效果，如反弹或弹性振动，而这些对于实现逼真的动画效果（但非必需的）是非常重要的。
    - 如果需要依次运行三组以上的动画，我建议使用 JavaScript。
      - CSS 中对动画的运行顺序是通过延迟来控制的，这是很复杂的。
      - 当你调整时间的时候，不得不重新计算所有的延迟。
      - 可以通过监听原生 JavaScript 事件来解决这个问题，但这样在编码时会切换不同语言，也不是很好的方案。
      - 持续时间长、复杂、有运行顺序的动画更容易在 JavaScript 中编写和阅读。
    - 对沿着路径运动效果的支持还不是很好
    - CSS + SVG 动画会有些奇怪的问题。
      - 一个例子是在 Safari 浏览器中，动画中同时使用不透明度和变换可能会失效或产生奇怪的影响。
      - 另一点是在 Web 规范中，对于 CSS 变换原点的定义并不是人们通常理解的那样，从而当变换应用到元素上时会产生预期之外的效果。
      - 希望 SVG2 能解决这个问题，而现在对于移动端的 CSS 和 SVG 动画，有时需要一些特殊技巧才能保证动画符合预期。
      - 那些使用 CSS 的动画框架，在处理大量效果的同时（例如 GSAP），可以对其进行修正。
    - 编写 CSS 动画时需要声明关键帧，然后编写元素本身的 CSS 来使用动画。
      - 这意味着运行动画所需的代码需要维护两个地方。
      - 有时这样很好，方便对动画的复用。
      - 但大多数情况下，这意味着可读性被破坏，因为你必须在两个地方更新代码。
- requestAnimationFrame
  - window 对象上的原生方法。
  - 这个方法非常赞，在 JavaScript 引擎的控制下，它确定了最适合当前环境的动画帧速率，并且只会以这个速率运行。
  - 例如，在移动设备上不会像在桌面设备上那样使用高帧率。
  - 当浏览器未获得焦点时，动画也会停止运行，以免不必要地占用系统资源。
  - 因此，requestAnimationFrame()是一个性能非常好的动画实现方式，后面我们讨论的大部分框架都在内部使用了它。
  - requestAnimationFrame()以类似递归的方式进行工作，它在绘制动画队列的下一帧之前会执行逻辑，然后再次调用自己，继续执行。
  - 这可能听起来有点复杂，但这样的实现方式意味着你有一系列不断运行的命令，因此它的插入可更好地呈现中间步骤。
- 尽管 canvas 基于栅格图形，而 SVG 基于矢量图形，你仍然可以在 canvas 中使用 SVG。
- web animations api 
  - 优点
    - 实现序列动画很简单，代码清晰易读
    - 性能表现似乎很好，不过我还是建议你使用自己的性能测试来看一下。
  - 缺点
    - 浏览器支持度还不够高，可以使用polyfill
- 第三方框架
  - GSAP优点
    - 对于非原生动画的支持，表现非常出色
    - GSAP 时间轴的很多功能比当前WAAPI的实现更为强大
      - 对于我来说，更关注的是 SVG 的跨浏览器稳定性，以及在 SVG 中通过一行代码管理大量动画执行的能力。
      - 插件丰富
      - 它解决了 SVG 跨浏览器的困扰，因此特别适用于移动端。
      - 提供了ease-visualizer编辑器来创建缓动函数
      - 由于 GreenSock 可以对任意两个整数区间做补间动画，因此你可以实现一些很酷的效果，如对 SVG 滤镜实现动画，可获得一些令人惊叹的效果
  - GSAP缺点
    - 部分插件收费
    - 更新维护依赖
  - mo.js
  - bodymovin': 用于在Adobe AfterEffects中构建动画，并可导出svg和js
  - SMIL(Synchronized Multimedia Integration Language)
    - 不推荐使用
    - 原生的 SVG 动画规范，它允许直接在 SVG DOM 中进行移动、变形，甚至与 SVG 进行交互。
    - 使用 SMIL 存在很多优缺点，但最大的问题会让我转向废弃这个方案：SMIL 正在失去支持。
  - velocity
    - 语法类似jquery
  - snap.svg
    - 并不是专注于动画的库，擅长svg的dom操作
  - react-motion
    - 被认为是react中实现动画的最佳方法
    - 提供元素的质量和初始物理状态，元素就会运动，而不需要像传统的基于坐标的运动方式
    - 但有一点比较难处理。如果有两个不同的元素必须在同一时间启动，并同时到达终点，那么你会发现它们很难「齐头并进」。
    - 优点
      - 美观
      - 独特的弹性效果
    - 缺点
      - 与css animation暴露的api设计关系不大，写的代码更多
      - 由于代码的复杂性，实现顺序执行动画并不像其他方案那样直观和清晰。
      - onRest 仍然没有提供交错动画的参数
  - react-canvas
    - 由 Flipboard 团队开发的，他们想在 DOM 上实现 60fps 的动画效果。
    - 这个报告已经有段时间没更新了，并且这个项目只关注 UI 元素，因此实现其他类型的动画需要一些额外的工作
  - react-konva
    - 很容易就能创造出好看的图形，但动画能力有些缺乏，开发人员也在文档中承认了这一点
- 用GreenSock做动画
- GreenSock中的时间轴
- GreenSock的插件 MorphSVG和BezierPlugin
- GreenSock交错动画、颜色渐变、SplitText
- GreenSock Draggable插件和DrawSVG插件
- mo.js 提供以声明式语法来完成元素的动画和动效的功能
- react-motion
  - 和基于序列的技术不同
  - 在序列技术如css和GreenSock时间轴中，我们并没有真正使用时间来控制插值
  - 在基于游戏的物理运动中，通过给元素mass和spring传递参数，然后元素运动起来，这样可以得到一个类似现实的阻尼运动
- 使用js实现动画
  - 制作 SVG 动画效果不需要任何库。
  - 一个高性能的制作方法是使用 request-AnimationFrame（rAF）。
  - rAF 可以替换其他原生 JavaScript 方法，比如 setInterval()
  - rAF 的工作方式是在下一次重绘浏览器时，将动画更新相关函数传递给浏览器。
  - rAF 调用不会创建一个嵌套的调用堆栈，因为这可能导致性能问题。相反，它们将回调函数添加到由浏览器管理的队列中，并且在特定时间只有一个函数实例在运行。
  - requestAnimationFrame()的神奇之处在于，它能以每秒 60 帧的速度运行，
    - 但在浏览器底层，它会根据你的设备情况计算出运行的速度：桌面端运行得更快，在移动设备上运行速度会变慢。
    - 当标签切换到后台时，它也会停止工作，因此这样可以节省电池寿命，同时在不需要运行的时候不会占用资源。
    - 这样处理节省了开发者的工作，我们不需要在 setInterval()中手动处理这些问题，也不需要为不同的浏览器或不活动的标签设置不同的间隔时间。
    - 不需要将动画的所有代码都放在函数中——也可以调用另一个函数，这个函数用于动画更新。rAF 中的回调函数通常用于判断动画是否已经「完成」（除非你想要一个无限循环的动画）。
- 响应式动画
  - 我们至少应该确保在移动端创建的动画能发挥很好的作用，而且在移动设备上创建的互动能提供所有功能，这里可以使用像 ZingTouch和Hammer这样的库，使用滑动或手势检测来通过本机的交互检测
  - Web 响应式设计可以在 `<meta>` 标签中指定 initial-scale=1.0，以便在调用操作之前，设备不需要等待默认的 300ms。
  - 互动触摸事件必须有一个更大的触摸目标（40×40px 或更大）或者使用@media（pointer:coarse）。
  - 使用 GSAP 的首要原因是其对 SVG Transform 属性的跨浏览器支持
  - 请注意，我们这里没有使用基于百分比的变换。动画是建立在 viewBox 基础上的行为，因此，响应式开发变得像删除宽度和高度一样简单
- 组件库的设计、原型化和动画原理
  - React 和 Vue 可以完美地实现组件的多次复用，所以你可以创建一些通用动画组件，这些组件允许你在不同的地方使用
  - 动画组件的优先级
    - page transition > dropdown pattern > loading spinner
  - 时间就是金钱，动画可以提前设计，但最后实现作为点缀
