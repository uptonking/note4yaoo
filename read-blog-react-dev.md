---
tags: [blog, react]
title: read-blog-react-dev
created: '2020-06-22T07:53:20.287Z'
modified: '2020-06-24T08:36:08.086Z'
---

# read-blog-react-dev

## React组件设计实践总结
- 参考
  - https://juejin.im/post/5cd7f2c4e51d453a7d63b715
  - [React Bits中文版](https://hateonion.me/books/react-bits-cn/)
- 类型检查
  - 静态类型检查的作用
      - 可以在开发时就避免许多类型问题, 减少低级错误的
      - 通过类型智能提示, 可以提高编码的效率
      - 有利于书写自描述的代码(类型即文档)
      - 方便代码重构，配合IDE可以自动重构
  - 有了Typescript之后可以安全地约束Props和State, 没有必要引入React.PropTypes
  - 函数组件的类型检查
      - ComponentNameProps形式命名Props类型并导出
      - 优先使用FC类型来声明函数组件
      - 不要直接使用export default导出组件，这种方式导出的组件在React Inspector查看时会显示为Unknown
- 高阶组件
  - 问题
      - 在React Hooks出来之前, 高阶组件是React的一个重要逻辑复用方式。比较而言，高阶组件比较难以理解, 容易造成嵌套地狱(wrapper)，对Typescript类型化也不友好
      - ref使用较复杂
  - 实现方式
      - 属性代理 Props Proxy
          - 操作props
          - 获取ref
          - 抽离state
      - 反向继承 Inheritance Inversion
          - 渲染劫持
      - 高阶组件使用
          - 要给hoc添加class名，便于debugg
          - 静态方法要复制
          - refs不会自动传递
          - 不要在render方法内部使用高阶组件
      - 参考
          - https://github.com/sunyongjian/blog/issues/25
          - https://github.com/MrErHu/blog/issues/4
          - 装饰器模式
- 事件处理
  - 如果存在多个相同事件处理器, 则按照handle{Type}{Event}命名, 例如handleNameChange.
  - 和原生html元素一样, 自定义组件应该暴露自己的事件处理器类型, 尤其是较为复杂的事件处理器, 这样可以避免开发者手动为每个事件处理器的参数声明类型
  - 自定义事件处理器类型以{ComponentName}{Event}Handler命名，为了和原生事件处理器类型区分, 不使用EventHandler形式的后缀
- 组件相关问题
  - 所有原生元素props都继承了React.HTMLAttributes, 某些特殊元素也会扩展了自己的属性, 例如InputHTMLAttributes
- 组件组织
  - 如果组件不需要状态, 则使用无状态组件
  - 性能上比较: 无状态函数 > 有状态函数 > class组件
  - 最小化props(接口)，不要传递超过要求的props
  - 如果组件内部存在较多条件控制流, 这通常意味着需要对组件进行抽取
  - 不要过早优化，只要求组件在当前需求下可被复用, 然后随机应变  
- 展示组件
  - 是一个只关注展示的'元件', 为了可以在多个地方被复用, 它不应该耦合'业务/功能', 或者说不应该过渡耦合，像antd这类组件库提供通用组件显然就是'展示组件'
  - 要以一种'第三方组件库'的标准来考虑组件的设计, 减少与业务的耦合度, 考虑各种应用的场景, 设计好公开的接口
- 容器组件
  - 一般以'高阶组件'形式存在, 它一般从外部数据源(redux这些状态管理器或者直接请求服务端数据)获取数据, 然后组合展示组件来构建完整的视图
- 分离逻辑和视图
  - 容器组件和展示组件的分离本质上是逻辑和视图的分离. 在React Hooks出现后, 容器组件可以被Hooks形式取代, Hooks可以和视图层更自然的分离, 为视图层提供纯粹的数据来源.
  分离方式
      - hooks
      - 高阶组件
      - Render Props
      - Context
- 按照UI划分为布局组件和内容组件
  - 布局组件用于控制页面的布局，为内容组件提供占位，通过props传入组件来进行填充，比如Grid, Layout, HorizontalSplit
  - 内容组件会包含一些内容，而不仅有布局。内容组件通常被布局组件约束在占位内，比如Button, Label, Input
- 表单组件
  - 数据录入组件, 或者称为表单, 对于自定义表单组件, 最好保持一致的API
  - 全都用受控组件实现
- 组件拆分
    - 当render()方法的JSX结构非常复杂的时候, 首先应该尝试分离这些JSX, 最简单的做法的就是拆分为多个子render()方法或子组件
    - 抽离无状态组件
    - 将逻辑控制部分抽离到hooks或高阶组件中
    - 按照单一职责原则拆分为更小组件
- 组件文档化
  - 推荐使用storybook
  - 可交互的组件示例
  - 可以用于展示组件的文档. 支持 props 生成和 markdown
  - 可以用于组件测试. 支持组件结构测试, 交互测试, 可视化测试, 可访问性或者手动测试
  - 丰富的插件生态
- css的问题
  - Global Namespace
      - CSS的选择器是没有隔离性的, 不管是使用命名空间还是BEM模式组织, 最终都会污染全局命名空间
      - 解决的方向: 生成唯一的类名; shadow dom; 内联样式; Vue-scoped方案
  - Dependencies
      - 很难清晰地定义某个特定组件依赖于某段特定的CSS代码，不能随便修改你的样式, 以免破坏其他页面或组件的样式
      - 解决的方向: 组件是一个内聚单元, 样式应该是和组件绑定的，最基本的解决办法是使用类似BEM命名规范来避免组件之间的命名冲突, 再通过创建优于复用, 组合优于继承的原则, 来避免组件间样式耦合;
  - Dead Code Elimination
      - 很难判断哪些样式属于那个组件; 在加上 CSS 的'叠层特性', 更无法确定删除样式会带来什么影响
      - 解决的方向: 如果样式的依赖比较明确，则可以安全地移除无用代码
  - Minification
      - 压缩类名也会减低代码的可读性, 变得难以调试
      - 解决的方向: 由工具来转换或创建类名
  - Sharing Constants
      - 常规的 CSS 很难做到在样式和 JS 之间共享变量, 例如自定义主题色, 通常通过内联样式来部分实现这种需求
      - 解决的方向: CSS-in-js
  - Non-deterministic Resolution/CSS解析方式的不确定性
      - 如果按需加载CSS, 则无法确保他们的解析顺序, 进而导致错误的样式应用到元素
      - 解决方向：避免使用全局样式，组件样式隔离；样式加载和组件生命周期绑定
  - Isolation
- 组件样式管理
  - 组件的样式应该是可以自由定制的
      - 应该考虑组件的各种使用场景，所以一个好的组件必须暴露相关的样式定制接口，至少需要支持为顶层元素配置`className`和`style`属性
      - 这两个属性应该是每个展示型组件应该暴露的props
  - 避免使用内联CSS
      - 内联CSS不支持复杂的样式配置, 例如伪元素, 伪类, 动画定义, 媒体查询和媒体回退
      - 内联样式通过 object 传入组件, 内联的 object 每次渲染会重新生成, 会导致组件重新渲染. 当然通过某些工具可以将静态的 object 提取出去
      - 不方便调试和阅读
      - 内联CSS适合用于设置动态且比较简单的样式属性
      - 社区上有许多CSS-in-js方案是基于内联CSS的, 例如 Radium, 它使用JS添加事件处理器来模拟伪类, 另外也媒体查询和动画. 不过不是所有东西都可以通过JS模拟, 比如伪元素
  - 通用的组件库不应该耦合CSS-in-js/CSS-module的方案，部分技术是需要构建工具支持的，建议使用原生CSS或者将SCSS/Less这些预处理工具作为增强方案
  - 使用原生CSS, 再配合BEM命名规范. 这种最简单方式, 能够满足大部分需求
- 图标管理
  - antd 3.9之后使用svg图标代替了font图标 
  - 如今CSS-Image-Sprite早已被SVG-Sprite取代. 而在React生态中使用svgr更加方便, 它可以将svg文件转换为React组件, 也就是一个普通的JS模块
  - 转换为普通JS文件, 方便代码分割和异步加载
  - 相比svg-sprite和iconfont方案更容易管理
  - svg可以通过CSS/JS配置, 可操作性更强，相比iconfont支持多色
  - 支持svgo压缩
- 样式单位
  - Bootstrap v4全面使用rem作为基本单位, 这使得所有组件都可以响应浏览器字体的调整
  - rem可以让整个文档可以响应html字体的变化, 经常用于移动端等比例还原设计稿
  - em在弹性组件中使用也很有效
- css编码规范
  - airbnb css/sass
  - aotu
  - fex-team
- CSS-in-JS
  - styled-components特性
      - 自动生成类名，解决CSS的全局性样式冲突
      - 样式和组件绑定，可以和组件一起进行代码分割和异步加载
      - 自动添加厂商前缀
      - 提供了一些CSS预处理器的语法
      - 支持theme修改
      - 支持react-native
      - 支持服务端渲染ssr
      - 支持stylint, 编辑器高亮和智能提示
      - 支持全局样式
          - 全局样式和组件生命周期绑定, 当组件卸载时也会删除全局样式
          - 全局样式通常用于覆盖一些第三方组件样式
      - 缺点
          - css-in-js需要一个JS运行时, 会增加js包体积
          - 相比原生CSS会有更多节点嵌套(例如 ThemeConsumer)和计算消耗
          - 不能抽取为CSS文件
- CSS Modules
  - 比较轻量，不需要JS运行时, 因为他在编译阶段进行计算
  - 所有样式默认都是 local, 通过导入模块方式可以导入这些生成的类名
  - 可以和CSS proprocessor 配合
  - 支持非标准的语法, 例如:global, :local, :export, compose:
- 高阶组件原理
  - 高阶组件是函数，它接收原始组件并返回原始组件的增强/填充版本
  - 高阶组件是一种用于复用组件逻辑模式,最为常见的例子就是redux的connect和react-router的withRouter，高阶组件最初用于取代mixin
      - 逻辑复用，把一些通用的代码逻辑提取出来放到高阶组件中, 让更多组件可以共享
      - 分离关注点，将行为层或者业务层抽取到高阶组件中来实现, 让展示组件只关注于UI
  - 高阶组件实现方法
      - 属性代理：最常用，代理传递给被包装组件的props, 再对props进行操作
      - 反向继承：高阶组件继承被包装的组件
  - 高阶组件作用
      - 渲染劫持: 即控制被包装组件的渲染输出
      - 操作state: state一般属于组件的内部细节, 通过继承的方式可以暴露给子类，可以增删查改被包装组件的state，一般不建议这么做
      - 避免重复渲染: 例如 React.memo
- Render Props(Function as Child)
  - 是指一种在Reac 组件之间使用一个值为函数的prop在React组件间共享代码的简单技术
  - 当 props 为函数时, 父组件可以通过函数参数给子组件传递一些数据进行动态渲染
  - 缺点：可读性差
- 抽象出容器组件
  - 大部分情况下, 组件表示是一个 UI 对象. 其实组件不单单可以表示 UI, 也可以用来抽象业务对象
- hooks
  - hooks首先是要解决高阶组件或者Render Props的痛点
  - 很难在组件之间复用状态逻辑
      - hooks将状态逻辑从组件中脱离, 让它可以被单独的测试和复用
      - hooks可以在组件之间共享, 不会影响组件的结构
  - 复杂的组件难以理解
      -  Hooks允许您根据相关部分(例如设置订阅或获取数据)将一个组件分割成更小的函数，而不是强制基于生命周期方法进行分割
      - 还可以选择使用一个reducer来管理组件的本地状态，以使其更加可预测
  - 基于class的组件对机器和用户都不友好
      - hooks解决: 基于闭包的函数式组件
  - hooks建议
      - 只能在组件顶层调用 hooks。不要在循环，控制流和嵌套的函数中调用 hooks
      - 只能从React的函数组件中调用 hooks
      - 自定义hooks使用use*命名
  - hooks使用场景
      - 副作用封装和监听: 例如 useWindowSize(监听窗口大小)，useOnlineStatus(在线状态)
      - 副作用衍生: useEffect, useDebounce, useThrottle, useTitle, useSetTimeout
      - DOM事件封装：useActive，useFocus, useDraggable, useTouch
      - 获取context
      - 封装可复用逻辑和状态: useInput, usePromise(异步请求), useList(列表加载)
          - 取代高阶组件和 render Props. 例如使用 useRouter 取代 withRouter, useSpring 取代旧的 Spring Render Props 组件
          - 取代容器组件
          - 状态管理器: use-global-hook, unstated
      - 扩展状态操作: 原始的 useState 很简单，所以有很大的扩展空间，例如 useSetState(模拟旧的 setState), useToggle(boolean 值切换)，useArray, useLocalStorage(同步持久化到本地存储)
  - hook在淡化组件生命周期的概念, 让开发者更专注于状态的关系, 以数据流的方式来思考组件的开发
- 组件类继承
  - React偏向于函数式编程的组合模式, 面向对象的继承实际的应用场景很少
  - 当需要将一些传统的第三方库转换成React组件库时, 继承就可能派上用场，因为这些库大部分是使用面向对象的范式来组织的
  - 可以通过继承的方式将他们生命周期管理抽取到父类上
- 常用组件
  - 表单
  - 模态框
      - Modal.confirm违反了React的模式吗？
- Context
  - 使用场景
      - 共享对于组件树而言是全局的数据，如当前认证的用户, 主题, i18n 配置, 表单状态
      - 组件配置, 如antd的ConfigProvider
      - 跨组件通信，不推荐通过事件进行通信, 而是通过状态进行通信
      - 依赖注入
      - 状态管理器，Context经过封装可以基本取代Redux和Mobx这些状态管理方案
  - Context的作用域是子树, 也就是说一个Context Provider可以应用于多个子树, 子树的Provider也可以覆盖父级的Provider的value
- 路由状态
  - 传统的路由主要用于区分页面，使用对象配置方式, 给不同的url分配不同的页面组件, 当应用启动时, 在路由配置表中查找匹配URL的组件并渲染出来
  - React-Router v4中`<Route/>`是一个普通React组件, 它在渲染时判断是否匹配URL, 如果匹配就渲染指定的组件, 不匹配就返回null
  - 此时URL不再是简单的页面标志, 而是应用的状态
  - 应用构成也不再局限于扁平页面, 而是多个可以响应URL状态的区域(可嵌套)
- React组件开发规范
  - Airbnb React/JSX Style Guide
  - React Bits
  - react-in-patterns
- 状态管理
  - 现在的前端框架(包括React)的一个核心思想就是数据驱动视图, 即`UI = f(state)`
      - 这种开发方式的变化其实得益于Virtual-DOM，它使得我们不需要关心浏览器底层 DOM 的操作细节，只需关心状态(state)和映射关系(f)
      - 随着state的复杂化, 框架现有的组件化方式很难驾驭 f(视图的映射关系变得复杂, 难以被表达和维护); 或者相关类型的应用数据流本来就比较复杂, 组件之间的交互关系多样，本来难以使用UI = f(state)这种关系来表达; 或者应用的组件状态过于离散，需要统一的治理等等。就有了状态管理的需求
  - 现有状态管理的方式
      - 分离视图和状态：状态管理器擅长状态管理，所以他们一般会将应用状态聚合在一起管理，而视图退化为只关注展示的视图
      - 约束状态的变更：Redux要求通过dispatch+reducer, mobx要求数据变更函数使用action装饰或放在flow函数中，目的就是让状态的变更根据可预测性
      - 单向数据流：数据流总是按照Store -> View -> Store, 简化数据流
      - 各自独立的静态页面，引入状态管理就是过度设计了
  - 状态管理的使用场景
      - 组件之间需要状态共享。同一份数据需要响应到多个视图，且被多个视图进行变更
      - 需要维护全局状态，并在他们变动时响应到视图
      - 数据流变得复杂，React组件本身已经无法驾驭，例如跨页面的用户协作
      - 需要统一管理应用的状态。比如实现持久化，可恢复，可撤销和重做
- 使用Context API来进行状态管理
  - Hooks+Context进一步简化，可以用于满足简单的状态管理需求
  - 体验
      - 没有外置的状态. 状态在组件内部，没有方法从外部触发状态变更
      - 缺少约束。没有约束会导致风格不统一，好处是可以自定义自己的约束
      - 性能优化。需要考虑Context变更带来的性能问题
      - 调试体验不如Redux
      - 没有数据镜像, 不能实现诸如事件管理的需求
      - 没有Redux丰富的生态
- Redux
  - 单一数据源 -> 可预测，简化数据流：数据只能在一个地方被修改
  - 单向数据流 -> 简化数据流, 可预测
  - 不能直接修改状态 -> 可预测
  - 通过中间件隔离副作用 -> 可预测
      - Redux的核心概念就是reducer，是一个纯函数，redux提供了中间件机制，实现各种副作用，比如异步请求，可以利用中间件机制，实现通用的业务模式，减少代码重复
  - Devtool -> 方便调试。通过开发者工具可以可视化数据流
  -  You Might Not Need Redux，直到碰到下面这些问题
      - 需要持久化应用状态, 从本地存储或服务器返回数据中恢复应用
      - 需要实现撤销重做这些功能
      - 实现跨页面的用户协作
      - 应用状态或数据流很复杂时
      - 许多不相关的组件需要共享和更新状态
      - 外置状态
  - 状态设计
      - 业务数据还是UI数据? 
      - 状态是否会被多个组件或者跨页面共享？
      - 状态是否需要被持久化、镜像化、时间旅行?
      - 状态是否需要跨越组件的生命周期？
  - Redux官方推荐范式化State
      - 扁平化结构树, 减少嵌套，减少数据冗余
      - 也就是倾向于更方便被更新和存储，至于视图需要什么则交由reselect这些库进行计算映射和组合
      - 不管是redux还是二次封装框架都不是特别方便Typescript进行类型推导，尤其是在加入各种扩展后
- Mobx
  - 问题
  - 组件侵入性。需要改变React组件原本的结构, 例如所有需要响应数据变动的组件都需要使用observer装饰，组件本地状态也需要observable装饰, 以及数据操作方式等等，对mobx耦合较深, 日后切换框架或重构的成本很高
  - Mobx vs Redux
- RxJS
  - 非常适合复杂异步事件流的应用
- React应用性能优化
  - 性能优化通用方向
  - 减少计算量
      - 对应到React中就是减少渲染的节点 或 降低组件渲染的复杂度
      - 不要在渲染方法render()中进行不必要的计算
          - 不要进行数组排序、数据转换、订阅事件、创建事件处理器等等
          - 渲染函数中不应该放置太多副作用
      - 减少不必要的嵌套，一般不必要的节点嵌套都是滥用高阶组件、RenderProps导致的
      - 虚拟列表只渲染当前视口可见元素，减少渲染的节点
      - 惰性渲染，只在必要时才去渲染对应的节点，如树形选择器，模态窗，下拉列表，折叠组件等
      - 选择合适的样式方案，运行时性能CSS > 大部分CSS-in-js > inline style
  - 利用缓存避免重复渲染
      - 对应到React中就是如何避免重新渲染，利用函数式编程如memo来避免组件重新渲染
      - 使用纯组件，控制组件的副作用
      - 通过shouldComponentUpdate()来比对state和props, 确定是否要重新渲染
      - 简化props，简化的props更容易理解, 且可以提高组件shallowCompare的性能
      - 避免使用箭头函数形式的事件处理器作为属性，每次渲染时都会创建一个新的事件处理器
      - 使用不可变的数据结构
      - 不是所有状态都应该放在组件的state，如果需要组件响应它的变动, 或者需要渲染到视图中的数据才应该放到state 
  - 精确重新计算的范围
      - 对应到React中就是绑定组件和状态关系, 精确判断组件更新的时机和范围，只重新渲染'脏'的组件，或者说缩小渲染范围
      - 精细化渲染指的是只有一个数据来源导致组件重新渲染, 比如说A组件只依赖于a数据，那么只有在a数据变动时才渲染A, 其他状态变化不应该影响组件A
      - 慎用Context，一旦Context值变动，所有依赖该Context的组件会forceUpdate
          - 明确状态作用域, Context只放置必要关键的，被大多数组件所共享的状态，比较典型的是鉴权状态
          - 一般都不会裸露地使用Context.Provider, 而是封装为独立的Provider组件

