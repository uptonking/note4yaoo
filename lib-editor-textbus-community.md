---
title: lib-editor-textbus-community
tags: [community, textbus]
created: 2023-02-21T00:08:57.962Z
modified: 2023-02-21T00:09:17.475Z
---

# lib-editor-textbus-community

# guide

- forum
  - [feat: 删除 qq 群 · textbus_20230704](https://github.com/textbus/textbus/commit/865aa7ec9bfe473609224b2760cfb9f536789462)
# discuss
- ## 

- ## 

- ## 虚拟 DOM 终于完成，只差 diff 了_20230520
- 加上 diff，再加个时间切片，齐活了

- ## 像我这样的开源作者，全是用爱发电
- 恩，不过我见过几个开源底层代码，再开发商业版卖其实也挺好的
- 大多数开源都是爱，能赚钱是基本没有
  - 编辑器又是一个很冷门的领域
  - 而且大多数场景，不需要那么多定制
  - 所以 textbus 注定小众
- dataease这个大屏框架就是这样的，开源底层，plus模块收费
  - 哎，编辑器是数据需求比较少的
  - 基本大家找个开源的能用就用了，因为没那么多需求
  - 这个确实不太好做商业版本
- 学习交流的开源项目，基本没大用
  - 要有创新，解决特定领域问题
- 像国外不就开源项目很多，很多作者都是兴趣爱好去做的
  - 大多数人都是在作者的思路上添砖加瓦
  - 碰撞出一个思路
- 开源主要是能收集一些需求
  - 解决方案还是要自己想
  - 至少目前，还没有人给我提供解决问题的思路
  - 没有点经验，根本上不了手
- 搬砖的比较多，能做框架的比较少，比如我就是前端搬砖
  - 现在把开发当兴趣的也越来越少了

- ## 弄个飞书山寨版，感觉只要一个月
  - 不过要把插入的其它控件做完，就要很很久了
- 感觉飞书核心价值应该是搭配它一套企业管理方案，软硬件兼备才能发挥飞书作用。又或者说飞书是把一套企业管理方案变成了工具
- 我没用过飞书不太懂它多强，不过这种思路可以拓展到很多领域，比如我现在想做的是把一些学习上的方法论变成工具

- ## 我看onlyoffice全部采用的是canvas
- 实现一个功能完备可用的渲染引擎不是一件容易的事
  - 我不觉得我会比 dom 做得更好
- 另外，用 canvas 实现视图层，必然导致第三方扩展困难
  - 本来弄富文本对很多人来说，都比较困难了，现在还要学习怎么弄视图层
  - 很少有人能定制

- 其实后端无非就是增删改查、集群、队列、高并发。没有前端的世界精彩
- 前端要上深度，就图形、游戏引擎，文档
  - 很多项目的感觉难度高，不是因为深度，而是多，导致的复杂度上升

- 图形目前看，商业场景不明确
  - 就算你搞个 echarts 什么的，也只是在边缘的数据展示环节
  - 很少有业务是依赖于图形产生商业价值的

- ## 兜兜转转又弄回 contenteditable 了_20230225
- 为了兼容移动端是吧
  - pc 可以随便，移动只能原生
  - 能力不够，暂时没找到很好的在移动端画光标，而没有问题的路径

- ## 我甚至在想，要不要把组件再改回 class
  - 改回 class 干嘛， 函数组件不好写吗
  - class 有类型推断的优势
  - 函数组件有 hook 的优势
  - 一个类型更友好，一个组合更方便
- 为什么函数组件 类型推断有问题呀
  - 比如你要判断一个组件，用 class 直接 instanceof
  - 现在只能 typeof xxx && comp.name === 'xxx'
  - 并且下面这个还不能完全，扩展的方法无法推断，用类的话，就没有这个问题
  - 其实 class 里也可以用 hook，不过，这样就不能直接 new 了
- 你是要它能够自动推断，而不是用ts 告诉编译器类型信息是吧
  - 是的
  - 要通过特定的工厂去实例化 class，比如 context.createInstance(ClassComponent)，这样才能在 class 里使用 hook
  - 现在这种方式，也不方便做 component.createInstance(这里的参数）
和组件的 setup(这里接收){}
  - 这样也增加了一点点心智理解负担
- 所以没有两全的方法
  - 或者可以new，但是要约定一个比如 init 方法，在这个方法里可以使用 hook
  - 这个 init 必须是 textbus 来调用，方便创建 hook 上下文信息
- 1.0 就是用过class

- ## const [state, setState] = useState() 用这种模式，就必须要走 react的那种设计
- 对长文档有很大的性能问题要处理
  - 弄到最后，就造了个 react出来

- ## textbus 的性能瓶颈不在文档长度和大小上
- 在组件复杂度上
  - 如表格这种，如果单元格过多，textbus 类似把每个组件和插槽都调用了 react memo
  - 但组件本身很大的话，这个通用算法就解决不了了
