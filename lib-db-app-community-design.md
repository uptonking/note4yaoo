---
title: lib-db-app-community-design
tags: [community, database, design]
created: 2023-09-17T17:50:30.020Z
modified: 2023-09-17T17:50:49.932Z
---

# lib-db-app-community-design

# guide

# discuss-stars
- ## 

- ## 

- ## 

- ## 
# discuss-markdown/ooxml/epub-db
- ## 

- ## âœ¨ [Obsidian Dataview: Turn Obsidian Vault into a database you can query from | Hacker News_202205](https://news.ycombinator.com/item?id=31407781)
- I sometimes wonder if learning how to use Dataview inside of Obsidian is too technical to get mass adoption, compared to WYSIWYG tools like Notion that let you build databases with nice UI filtering. But the performance of Dataview is so much better, and the control you have over queries so much more granular, that itâ€™s worth the learning curve. The Obsidian community is also incredibly good at helping new users learn, which makes me feel optimistic.

- **Hierarchical notetakers/outliners are becoming a new data structure for end users, specialized in knowledge management**. A kind of generalized, expandable spreadsheet.
  - The key development that I miss is that of reifying query results, allowing the user to use the data generated by a search as an object in itself. I even have a name for that reified object - a **wit** would be a collection of data compiled with a common criteria (representing a minimum unit of meaning, is a wordplay on bit being the minimum unit of knowledge), similar to a spreadsheet range. When tools like Obsidian or Logseq start **allowing the user to use query results as first-class data**, I predict that we will see a revolution in end-user process automation.
- Thanks! I had it as a vague idea for several years, though it has been getting a lot more concrete as I've seen new tools adopting similar approaches - but without any of them taking the final step of converting a search result collection into a user-accessible object ready for direct manipulation.
  - And now that I see tools adopting that style of data management, the concept allows me to see the commonalities among tools with quite different approaches - be it **tabular Nocode storage like Airtable or outliners like Roam, Workflowy and the like**. 
  - Whenever the tool returns a collection from a data gathering process, I see a wit that should be able to be extracted and further processed by the user.
  - BTW, the **main difference between a query result and a wit** is that you can store its items in the same structure as the rest of your content in the outliner, and send them to a new process (like spreadsheet cells, but with hierarchical data). Usually, query results are presented through a different interface than the rest of content, but a 'wit' should be homoiconic like Lisp.

- Outliners are used in this area for decades. What we have now is just a new hype-cycle, with new apps, new technologies and a new mix of features.
- Outliners have quite the fandom, but my issue with the traditional outliner is that they often trap data in outline form. Sure, most good outliners offer export options. Unfortunately, the second you've taken data from your outliner and exported it, you now have two versions of your data, and you've lost.
  - Logseq (and Obsidian) have changed this. Finally, a single document _is_ an outline, a backlink, a data source, a webpage, a presentation, and so on... The only thing the user has to do is work with that single page of information.
- So has Org-mode 10 years ago, XML 20 Years ago. HTML 30 years ago. More or less, the numbers may be a bit off.

- The main new aspect that logseq and Obsidian bring to the table is the possibility to backlink to any part of the hierarchical structure. The tools automatically compile all those links as a new data object, which the user can process without creating a script to gather all that data. HTML had the potential to popularize that feature 30 years ago (with a slightly more awkward syntax than Markdown), but browsers never got around to it.
  - Previous tools would require users to move content to a different tool (say, by copy-pasting the content of your files to a spreadsheet to apply formulas), destroying the possibility of having a central personal knowledge repository. In logseq / Obsidian, you can keep adding multimedia content to your structured knowledge base, and exploit that content without coding at all, or at most by creating simple declarative expressions.

- Linking is a fundamental concept of hypertext. And easy linking inside your dataspace, as also automatically listing backlinks, was already established with wikis 20+ years ago. Even hierarchies exists in wiki space for a long time now in several different ways.

- I was a heavy TiddlyWiki user in the past but moved away from it precisely because of its singe-HTML file design. Modern browsers like chrome made it virtually impossible to save an edited page. Not TW's fault per se, but ruined my experience with it. There is a way to install TW-5 with node.js as a directory tree but my ship has sailed. Now I am a happy obsidian user.

- I use tiddlywiki (with the nodejs setup) regularly. It's great until your wiki grows too large, at which point you need to wait ~10s for it to load even with modern hardware.
- Can Tiddlywiki be used by a team with simultaneous edits?
  - Not at all, AFAIK. Completely single-user in my experience.
  - You can. But you need to host it with a nodejs server.

- Logseq allows query via datomic
  - Minor correction, I don't think Datomic is used. I believe it uses a variation of DataScript and in turn DataLog for queries. Whereas Datomic is a DB which is also based on and uses DataLog queries.

- ğŸ¤” So many great features, but all these systems are missing the one true feature I really need, Link types. I see that Dataview gives some ability to have them, but it requires a very specific format that is pretty distinct from how the notes would be taken.
  - a simple [[Page Name]]{type:child} could be good, all I really need is a means of **filtering linked documents by their link type** (in a graph view/visualization) and ideally a method to query and display those. Dataview gives the second, though the first seems to require the link type to be a first class citizen.
  - you can use the supercharged links plugin and careful control of it's class types to achieve that, it's how I did it. I'm largely using schema.org types

- Before Obsidian there was ConntextedText. Few people knew it even back then, but it is quite powerful, packed with common wiki features like linking, attributes, querying (also display results as a table), transclusion, page graph visualisation, python integration, etc.

- ## ğŸ’¡ [Athens Research (YC W21) â€“ Open-Source Roam Research | Hacker News_202103](https://news.ycombinator.com/item?id=26316793)
- My only real reservation is that files are not in Markdown.
- ğŸ‘‰ğŸ» The current **major difference between markdown-based and db-based apps is block references**. Over time, the difference will become significant as knowledge bases grow in size.
  - CSV -> Excel -> SQL -> Distributed Cloud DBs
  - Furthermore, our database supports data types, including numbers, dates, etc. I don't think any networked notetaking app has executed well on tables and non-string types. UX for tables is generally not great for markdown.
- That should be true, but so far it is Roam with the biggest problems with performance, from 30+ seconds of loading each time you load/refresh tab to constant lags in normal usage for some users
  - I personally like the most this mixed approach of Logseq - app internally uses DataScript, but data is ultimately stored in plain files.

- Roam's performance suffers mainly on first-load because they are server-first, and they load the entire db into memory at the beginning (such that it's quite fast thereafter).
  - Once we have true local-first data structures with something like replikativ/datahike, we could still have fast in-memory, but also fast initial load.

- ğŸ‘‰ğŸ» Not markdown, but **asciidoc has first class support for blocks and references/attributes**.

- I don't see the advantage of converting an HTML to RDF because it would cover the entire spectrum. All the semantics might be lost. RSS is the smallest common denominator. If you agree somehow, you might be interested in that tool [0], it converts HTML to RSS using pattern matching.

- Me and some friends have played around with Roam a bit and we are baffled by the app. It just does not work well. It is a badly-designed, lower performance, glitchy note-taking app. You end up staring at its gaudy giant astrolabe loading spinner more often than not. We look at it and end up baffled why anyone would pay a monthly subscription for it!

- Could you please share some of your experience/plans regarding implementing cross-device sync?
- Which db is the source of truth?
  - Currently index.transit is the source of truth. When a user sees new changes, their current db is saved, and they have the option of opening the new one or continuing to edit the current version. The entire history of the db is saved right now ({timestamp}-username.index.transit.bkp) while we work on better conflict resolution and merging
- How will conflicts from offline editing be handled?
  - Don't have conflict resolution yet for offline editing
- Will you be able to see edits made in realtime across the devices?
  - We plan to make a websocket server for some the real-time UX.
# discuss
- ## 

- ## 

- ## ğŸ¤” [Ask HN: What are some examples of good database schema designs? | Hacker News_202002](https://news.ycombinator.com/item?id=22324691)

- [Gallery of database schema diagrams of open-source packages | Hacker News](https://news.ycombinator.com/item?id=23006159)

- Northwind Traders
- That made me laugh. My 2 cents after doing this long enough to recognise it
  - Aim for 3NF but not religiously. Still, if you need a flat table try a view.
  - Any ternary relationship can be modeled as a pair of binary relations (you'll never regret keeping it simpler)
  - You don't need EAV (Magento is a good example of why you shouldn't)
  - On the other hand don't serialize data (looking at you WordPress)
  - XML and JSON data types though are perfectly fine when you need to store an object
  - Every table should have a primary key (preferably an integer)
  - If you really want a string for your primary key make it a candidate key (why, because someone will insist on changing it)
  - E/R diagrams are your friend
  - So are Venn diagrams for visualizing a complex select

- 
- 
- 
- 
- 
- 

- ## å’ŒChatGPTèŠDBè®¾è®¡è·å¾—æ–°çŸ¥ï¼ŒNested Set Modelï¼š
- https://twitter.com/TooooooBug/status/1659041013800001536
  - å°†çˆ¶å­å…³ç³»æ˜ å°„åˆ°æ•°è½´ä¸Šå˜ä¸ºæ•°å­—èŒƒå›´çš„åŒ…å«å…³ç³»ï¼Œç„¶åé€šè¿‡æ•°å­—èŒƒå›´å¤§å°å°±èƒ½è®¡ç®—å‡ºå„æ¡è®°å½•çš„çˆ¶å­å…³ç³»ï¼Œé¿å…åå¤é€’å½’ã€‚
