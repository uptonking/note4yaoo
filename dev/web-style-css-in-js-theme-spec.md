---
title: web-style-css-in-js-theme-spec
tags: [css-in-js, style, theming, web]
created: 2019-11-30T10:00:18.020Z
modified: 2021-01-01T20:06:50.117Z
---

# web-style-css-in-js-theme-spec

# faq

- ## 为什么用css-in-js
- pros
  - naming is hard
  - scoped styles 局部样式
  - simple dynamic styling adapting to its props 动态样式
  - easy to create themeable components 切换主题
  - type check and code auto suggestion
  - support all of CSS plus nesting
  - better maintainability
    - easy to delete css
    - easy to find styles
    - css的样式层叠顺序更清晰，当很少使用全局样式时
    - 大型软件通常更重视可维护性和兼容性，性能通常不是最高
  - js is the future (for its ecosystem)
    - define style helper functions in js rather than sass
- cons
  - learning curve
  - css-in-js runtime cost in performance and size 
  - 技术选型时，参考知名项目或大公司项目的选择，但结论是大公司都没选css-in-js
- ref
    - css-in-js趋势：静态提取、theming支持、constraint-based props、atomic css-in-js
    - https://jxnblk.com/blog/why-you-should-learn-css-in-js/
    - https://mxstbr.com/thoughts/css-in-js
    - https://spin.atomicobject.com/2018/12/28/css-in-javascript-benefits/
    - https://medium.com/@lindsay_jopson/is-css-in-js-really-better-than-traditional-css-8ac5b3f7fc20
- css-in-js热门项目
  - Microsoft Fluent Design 自己实现了styled方法
  - Uber Base Design用的是styletron-react
  - SAP Fiori(react-jss)
  - 使用styled-components或emotion的项目
    - Atlassian Design, Github Primer Design
    - HP grommet, Zendesk Garden
    - Kiwi.com Orbit design, Esri Calcite Design
- 为什么用emotion/styled-components
  - styles written inline, but className auto generated and added to dom
- 为什么用styled-system
  - themed based component
  - consistent prop names and scalar values
- 为什么用glaze
  - Near-zero runtime, made possible by treat, Theming support, Static style extraction
  - Constraint-based layouts, popularized by Theme UI
  - Utility-first CSS, as implemented by Tailwind CSS
- 为什么采用styled形式的组件，而不用className，调用该api能够传入props，然后根据props计算新样式属性再添加到组件上
  - 只有高阶组件能做到，普通方法做不到
  - styled开发体验好，性能可能不是最好
- css prop vs scss prop，不用className
  - className不能给组件动态添加样式属性
    - 因为需要一个styled
  - 样式写法上，差别不大
  - debug时，emotion的styled比styled-components的组件少一层styled.button
  - css prop的组件有时比styled的少一层Context. Consumer
  - css prop比styled少一层styled
- className vs css prop
  - emotion的css方法返回的是字符串，@emotion/core的css方法返回的是一个对象，包含字符串和扁平化的样式属性值，可被styled方式使用，兼容性更好
  - 写法上，采用object style时，css prop可以少写一个css
  - className不会wrapper hell
- css prop可以类似styled，给组件添加样式属性吗
  - @emotion/core的css()方法中可以类似styled-system给组件添加样式属性吗
  - css prop的原理是通过babel插件调用库相关的jsx函数而不是React.createElement来创建组件，这个过程会通过高阶函数给组件添加样式属性
    - https://www.felixjung.io/posts/the-css-prop-in-emotion-10/
    - Babel’s React JSX plugin has an option to specify the function it uses to transpile JSX expressions. The plugin defaults to using React.createElement. But by relying on React.createElement, you can only use syntax, such as props, supported by React.createElement. So, if you provide a different function to transpile JSX, you can support a different syntax.
    - we use the jsx pragma (/** @jsx jsx */) to tell Babel it should use the jsx function imported from @emotion/core to transpile JSX. And that is all you need to do to use the css prop. You do not need Emotion’s Babel plugin.
    - Importing React in a component is not an actual module import. It merely tells Babel that your JavaScript module contains JSX, which should be transpired using the React JSX plugin (i.e., with React.createElement). Using the jsx pragma allows you to opt into the css prop on a per component basis, by changing the way that component’s file is transpiled by Babel. You only need to specify the pragma, if you use the css prop in your component’s JSX.
    - The styles will be evaluated and stored in Emotion’s cache under a class name. The class name is passed down to the React element through the className property.
    - you now have direct access to the theme context created by a ThemeProvider
  - css prop和styled最终生成组件的结构非常相似

- ## style object vs template literals(TTLs) 关于样式书写，使用模板字符串，还是对象
  - style object
    - 当需要动态变化的样式属性有很多时，使用对象cleaner
    - 样式对象更方便计算及复用，如spread operator和destructuring
    - 对象更容易进行类行检查，字符串css可能后面赋值错误
    - 更容易调试，通过ide跳转到定义，而不是手动搜索字符串
  - TTLs
    - 更接近熟悉的css
    - ide的提示更容易实现
    - 动态变化的属性较少时，插值函数少，cleaner
    - 可以直接在末尾添加重复行，方便调试
  - conclusion  
    - The more interpolations you use, the more object notation tends to win over template strings in terms of readability.
  - The interoperable `theme` object itself is an object, and keeping styles in a similar format helps reduce the API surface area. 
  - Using and parsing strings that represent embedded DSLs introduces overhead when mapping over key-value pairs.
    - Theme UI avoids this overhead for reasons related to performance, testing, and overall bundle size. 
    - For some of the same reasons that React itself uses JSX (i.e. function calls) instead of tagged template literals
  - In Stitches, you write CSS using the object style syntax. 
    - The reasons for this are: performance, bundle size and developer experience (type checks and autocomplete suggestions for both properties and values)
  - ref
    - https://theme-ui.com/motivation/ 
    - 要考虑熟练度、提示需求(对象比str适合)、复用现有样式等
    - 还可以使用分散写的单独的属性，类似 `<Box color="primary" size="lg" />`
    - https://levelup.gitconnected.com/react-css-in-js-es6-objects-vs-tagged-template-literals-71670e78995f
    - https://medium.com/@oleg008/template-strings-vs-objects-in-cssinjs-4028ecc420b2
    - https://spectrum.chat/styled-components/general/style-object-vs-template-literalls~789509f2-7460-4b4c-84bc-b169c2230132
    - https://www.christopherbiscardi.com/post/composition-of-styles-strings-vs-objects/
- pros for style object
  - css within component 
  - better type checking
- pros for template literal
  - support media queries, pseudo
  - easier to reuse existing css
  - better readability
- Permissive vs Restrictive component API
  - styled-system v5中一个函数暴露一组样式api，可能会过多，对性能影响大吗
  - 有人提出一种通用组件 `<comp type='ul/h1/input' p1='' p2=''>` ，支持1000+属性，每次创建都会遍历所有属性，并且性能也不差
  - theme-ui allows use of any styled-system prop on any component (or element) through use of the sx prop
  - https://spectrum.chat/styled-system/general/permissive-vs-restrive-component-apis~475715ea-a538-41be-8366-779226339650
  - https://github.com/universalstandard/ook (any camelCased css property)
  - https://spectrum.chat/styled-system/general/strict-component-api-with-styled-system~a6582471-99d2-4d2c-94d2-2a05de61d4c4
  - https://github.com/styled-system/styled-system/issues/562 (Style functions exposing extra props)
- 是否使用box based component
  - reflexbox is a ergonomic, responsive React layout and grid system. The original Box component™ since 2015

- ## 是否需要静态提取使用css-in-js创建的样式到单独的css文件
  - 有利有弊
  - https://github.com/emotion-js/emotion/blob/master/docs/extract-static.mdx
    - extractStatic is not recommended because it breaks composition and other powerful patterns from libraries like facepaint.
    - https://github.com/emotion-js/emotion/issues/858
  - https://github.com/styled-components/styled-components/issues/1018
    - There's SSR which sends only critical CSS, instead of all static CSS, for the entire page. You don't even need to do SSR, but can use snapshotting (react-snapshot) or generate a static page (gatsby, et al), which basically saves a SSR result to a html.
    - Static extraction doesn't generate dynamic CSS, which means your page will either appear broken until the JS executes, or you'll need to defer until the JS is loaded
    - Caching doesn't actually buy you an advantage, because the JS bundles will likely always change in tandem with the extracted CSS
  - https://github.com/callstack/linaria/issues/465
    - The reason this doesn't work is because styled system interpolates both the declaration name and the value. With linaria, you should only interpolate the value.
  - https://github.com/callstack/linaria/issues/409
    - No support for conditional CSS using the styled tag is the biggest hurdle for us moving to linaria from styled-components
  - use styled-system with linaria
    - not possible
    - https://github.com/styled-system/styled-system/pull/868
    - In terms of dynamic style from props, Linaria only accepts function interpolations on the value side of CSS property, and it must return the correct value. Neither accept style objects nor dynamic CSS string.

# css-in-js-spec

- Interoperable Style Transfer Format
  - https://github.com/cssinjs/istf-spec

# theming

- ## While I love the API and DX of Theme-UI (and derivative libraries like Chakra), they are fatally flawed without static CSS extraction. 
- https://twitter.com/jaredpalmer/status/1271482711132254210
  - Hooking every single component into that theme and calculating runtime styles is death by 1000 cuts. 
  - You pay a price for every single `<Box>`.
- One thing I've learned from using Tailwind in a component-based framework (React/Vue) is that neither fully static or fully dynamic is perfect. You've gotta do a mix of static for things that can be extracted, and dynamic for other things.
  - Tailwind is a great example of fully static. But if you have more than a few design tokens, and you want to generate variant classes (screen size, hover, focus) you end up with _too_ much CSS. This is why most Tailwind users reach for PurgeCSS. But that causes its own problems..
  - If you want a component like this `<button color="blue">` to render `<button class="text-blue-500 hover:text-blue-700 focus:text-blue-800">`, there's no guarantee that those classes will exist because they may be purged.
  - All this to say, I totally agree that 90% of CSS can be static, but that 10% is a real problem that has to be dealt with.
- Pinterest has a very fast `<Box>` component [implementation](https://github.com/pinterest/gestalt/blob/master/packages/gestalt/src/Box.js). it’s got Only 30 properties and mapped direct to css modules. No runtime theming.
  - It's been my experience as well with things like styled-components, etc. 
    - React is slow enough without having to double the number of components, parsing CSS strings, etc.
  - I think Linaria would work as a better foundation since theming is based on CSS variables. 
    - However, Tailwind and RNW's StyleSheet will still be more efficient in the long run as the app grows, because they have atomic classes.
  - Styletron is fine. 
    - Has good perf. Uber uses it. 
    - Any ThemeProvider is still a really really bad idea imho
    - How would you declare and access your theme? CSS variables only? Exported from a regular module?
    - Export from regular module. That’s how we do it.
  - Does what you're describing also apply to styled-components (using their ThemeProvider)? I know they support static extraction, but I specifically am not using it. Or is this a Theme-UI thing?
    - It's both, since both implement the "styled" API whereby CSS is a function of a components props and a global theme object is injected in to those props, which requires a Context Consumer wrapping every single styled component instance
  - I can’t say I’ve noticed any perf issues but this seems like something Theme UI could solve pretty easily with a plugin at build time for static sites or asynchronously when you initialize the theme provider

- ## Is static extraction seems realistic?
- Static extraction is realistic, at work we created library (something like Chakra but with some special features) and we try to generate theme for components to CSS and it looks promising
- Static extraction is definitely realistic and something I plan on digging into in the near future.
  - Theme UI definitely can be improved performance-wise, we just wanted to make sure we nailed down a solid DX before investing time on optimization.
  - It's about that time
- I agree it should be static, and with the current API I think it can eventually be transitioned to static calls. 
  - There's some current work glaze in this space 

- ## We really should stop using React Context for theming libraries when CSS Variables:
- https://twitter.com/buildsghost/status/1251569049940537345
  - Are capable of everything you need for theming purposes
  - Can just as easily be the underlying implementation detail of these libraries instead of React Context
  - Are measurably more performant
- CSS-in-JS libraries have become Very Fast (enough at least). 
  - But the CSS-in-JS theming libraries that everyone is using have not.
  - And the performance problems they (eventually) cause are going to be much harder to refactor your way out of.
- Everyone talks about css in js perfs lately, but no one provides any actual number so it means nothing.
- Unfortunately when you have to support IE, you're out of luck with CSS variables. 
  - CSS-in-JS solutions can be better polyfilled for older browsers in my experience.
- It'd be pretty easy to use progressive enhancement in those cases. 
  - Make every property: `background: ${theme.pageBackground};` to `background: #eee; background: var(--pageBackground); `
  - This is a pretty simple build-time transform, or at runtime with a stylis plugin using emotion
- I am very much with you on this. 
  - In fact I had a wip thing for my CSS in JS library style-sheet to add support for theme-ui via custom properties and extract em to static.
  - That said I think React Context shines when you want to subscribe selectively i.e. just a portion of the subtree or a few components. 
  - In that case you automatically get encapsulation i.e. upper and (important) lower boundaries without having to reset theme.
- Does reading from a theme file in context have a noticeable performance impact? 
  - I always assumed it’s pretty cheap as long as it’s not changed.
  - Using context thousands of times will eventually start having a performance impact. To be fair you can get away with it for a long time. But once you can't, now you have thousands of things to update
- Unfortunately that won't work if you need to make your lib cross platform with RNW. RN does not have css vars.
  - Context theming and core React code is more portable.
  - it's possible to compile to 2 targets - web & RN, which could use different theming solutions, or just have 2 flavors of the lib, depends on how do you author ur cross-platform code
  - it wouldn’t be that hard to build for the app level, slightly trickier when preparing such universal library but totally doable thanks to pkgJson["react-native"] support.
    - All boils down to how you want to consume theme exactly and some work on top of that
- Context is type safe and testable. CSS variables are not.
  - How do you prevent typos or name conflict with this?
    - Also, Context works on all browsers and doesn't need the browser to be tested (since it works with React-native too after-all)
  - There are polyfills that you can use and yes it is still experimental, 
    - however, there are benefits to using a future standardized API (i.e. eventually you'll end up shipping no code for that feature)
    - About the typos and name conflicts, take a look at the solution used in Linaria
    - Specifically `stylelint` lets you statically analyze your CSS-in-JS (zero runtime and built on CSS variables)
- Ionic uses css3 variables to handling themes for android, ios devices with dark, light theme.
- I think many people are using css in js not realising that plain css can do much of what they want, without runtime burden. It’s become the default.
  - That said, custom properties aren’t supported by IE, so that’s a thing.

- ## Use CSS Variables instead of React Context: How and why you should use CSS variables (custom properties) for theming instead of React context.
- https://twitter.com/kentcdodds/status/1324026743099781120
- We took a similar approach with @stitchesjs
  - Tokens are converted to CSS Custom Properties
  - Reference token in CSS value without prop-interpolation
  - Support nested and/or multiple themes on the same page
- The one thing I'm missing from CSS variables is to be able to use them in media queries
  - I guess there's no way around JS for now (if they depend on the theme).
- My favorite is both. 
  - Favor CSS variables but still update a context so that you can switch out the components for advanced use cases that have different rendering. 
    - Also update the CSS variables in `useLayoutEffect` so it happens at the same time as the context change.
  - And the more you use the CSS Vars for everything else, the fewer context consumers you'll have, 
    - so the only ones that consume the context are the ones that need to swap the implementation

# pieces

- https://calendar.perfplanet.com/2019/the-unseen-performance-costs-of-css-in-js-in-react-apps/
  - Don’t over-compose styled components
  - Prefer “static” components
  - Avoid unneeded React re-renders
  - Investigate whether a zero-runtime CSS-in-JS library like linaria can work
- https://github.com/necolas/react-native-web/tree/master/packages/benchmarks
- https://dev.to/wilsmex/css-in-2020-a-practical-guide-2p6g
- https://sebastienlorber.com/atomic-css-in-js
- https://areknawo.com/introducing-prototope-utility-first-css-in-js-library/
- https://www.infoq.com/news/2020/04/facebook-cssinjs-react-conf-2019/
  - stylex
  - new Facebook website: React/GraphQL/Relay 
- https://www.infoq.com/news/2020/01/css-cssinjs-performance-cost/
- https://dev.to/macsikora/css-in-js-did-we-do-something-wrong-l1j
- https://spectrum.chat/styled-components/general/styled-components-vs-emotion~47206c1b-a688-424e-9e96-6f265993587e
- https://itnext.io/css-in-js-vs-pre-post-processors-in-2019-8b1e20c066ed
