---
title: lib-net-http-ajax
tags: [ajax, http, network]
created: 2020-08-07T04:37:22.307Z
modified: 2023-02-06T09:14:40.114Z
---

# lib-net-http-ajax

# guide

- reactç¨‹åºä¸­ï¼Œé€šè¿‡äº‹ä»¶å¤„ç†å™¨å¦‚onClickè§¦å‘ç½‘ç»œè¯·æ±‚çš„å®ç°åº”è¯¥æ”¾åœ¨äº‹ä»¶å¤„ç†å™¨ï¼Œè¿˜æ˜¯æ”¾åœ¨useEffect?
  - ajaxæ”¾åœ¨äº‹ä»¶å¤„ç†å™¨å¦‚onClickï¼Œæ›´æ˜“ç†è§£
    - reactå‡†å¤‡ç§»é™¤[setState on unmounted Comp](https://github.com/facebook/react/pull/22114)çš„warningï¼Œæåˆ°äº†äº‹ä»¶å¤„ç†å™¨çš„side effectå¯èƒ½å¼•å‘é‡å¤è¯·æ±‚çš„é—®é¢˜
  - ajaxæ”¾åœ¨useEffect
    - âŒï¸ é¦–æ¬¡renderä¸åº”è¯¥è‡ªåŠ¨æ‰§è¡ŒuseEffectï¼Œå› ä¸ºajaxåº”è¯¥ç”±ç‚¹å‡»äº‹ä»¶è§¦å‘
    - âŒï¸ å…¶ä»–state/props/depsçš„å˜åŒ–ä¸åº”è¯¥è‡ªåŠ¨æ‰§è¡ŒuseEffectï¼Œå› ä¸ºajaxåº”è¯¥ç”±ç‚¹å‡»äº‹ä»¶è§¦å‘
    - âœ…ï¸ æ›´ç¬¦åˆreactä¸­æ‰§è¡Œside effectsçš„è®¾è®¡
    - âœ…ï¸ ç”¨æˆ·è¿ç»­ç‚¹å‡»æŒ‰é’®è§¦å‘äº‹ä»¶æ—¶ï¼Œå› ä¸ºstateæœªå˜ï¼Œä¸ä¼šé‡å¤è§¦å‘

- xhrä¼˜ç‚¹
  - æ”¯æŒå¹¿æ³›ï¼Œå…¼å®¹æ€§å¼º
- xhrç¼ºç‚¹
  - ä»£ç å†—é•¿ï¼Œxhrå¯¹è±¡æ“ä½œè¾ƒæ··ä¹±
  - callback hell
  - éœ€è¦æ‰‹åŠ¨è§£å†³CSRFæ”»å‡»

- fetchä¼˜ç‚¹
  - ä»£ç ç®€æ´ï¼Œpromiseè¾ƒå°‘callback
- fetchç¼ºç‚¹
  - è¿”å›å€¼ç±»å‹æ˜¯promiseï¼Œè¢«promiseçš„ç¼ºç‚¹é™åˆ¶
    - ä¸èƒ½å–æ¶ˆï¼Œåªèƒ½æ¶ˆè´¹ä¸€æ¬¡ï¼Œæ“ä½œç¬¦åªæœ‰thenå’Œcatch
  - æœ‰æå°‘xhråŠŸèƒ½æœªå®ç°ï¼Œå¦‚è¿›åº¦é€šçŸ¥

- observableä¼˜ç‚¹
  - æ“ä½œç¬¦ä¸°å¯Œ
- observableç¼ºç‚¹
  - éœ€è¦å¼•å…¥ç¬¬ä¸‰æ–¹å®ç°åº“ï¼Œå¢åŠ é¡¹ç›®å¤æ‚åº¦å’Œä½“ç§¯

- [Inside React Query_202212](https://tkdodo.eu/blog/inside-react-query)

- [Arrow Flight RPC â€” Apache Arrow](https://arrow.apache.org/docs/format/Flight.html)
# xhr/ajax
- åŸºäºåŸç”Ÿçš„XHRå¼€å‘ï¼ŒXHRæœ¬èº«çš„æ¶æ„ä¸æ¸…æ™°ï¼Œå·²ç»æœ‰äº†fetchçš„æ›¿ä»£æ–¹æ¡ˆã€‚
- æœ¬èº«æ˜¯é’ˆå¯¹MVCçš„ç¼–ç¨‹, ä¸ç¬¦åˆç°åœ¨å‰ç«¯MVVMçš„æµªæ½®ã€‚
- JQueryæ•´ä¸ªé¡¹ç›®å¤ªå¤§ï¼Œå•çº¯ä½¿ç”¨ajaxå´è¦å¼•å…¥æ•´ä¸ªJQueryéå¸¸çš„ä¸åˆç†
  - ï¼ˆé‡‡å–ä¸ªæ€§åŒ–æ‰“åŒ…çš„æ–¹æ¡ˆåˆä¸èƒ½äº«å—CDNæœåŠ¡ï¼‰ã€‚
# fetch/promise
- Fetchæ˜¯åŸºäºpromiseè®¾è®¡çš„ï¼ŒFetchçš„ä»£ç ç»“æ„æ¯”èµ·ajaxç®€å•å¤šäº†
- fetchä¸æ˜¯ajaxçš„è¿›ä¸€æ­¥å°è£…ï¼Œè€Œæ˜¯åŸç”Ÿjsï¼Œæ²¡æœ‰ä½¿ç”¨XMLHttpRequestå¯¹è±¡
- ç¬¦åˆå…³æ³¨åˆ†ç¦»ï¼Œæ²¡æœ‰å°†è¾“å…¥ã€è¾“å‡ºå’Œç”¨äº‹ä»¶æ¥è·Ÿè¸ªçš„çŠ¶æ€æ··æ‚åœ¨ä¸€ä¸ªå¯¹è±¡é‡Œ
- æ›´å¥½æ›´æ–¹ä¾¿çš„å†™æ³•
- æ›´åŠ åº•å±‚ï¼Œæä¾›çš„APIä¸°å¯Œï¼ˆrequest, responseï¼‰
- è„±ç¦»äº†XHRï¼Œæ˜¯ESè§„èŒƒé‡Œæ–°çš„å®ç°æ–¹å¼
- fetchåªå¯¹ç½‘ç»œè¯·æ±‚æŠ¥é”™ï¼Œå¯¹400ï¼Œ500éƒ½å½“åšæˆåŠŸçš„è¯·æ±‚ï¼Œéœ€è¦å°è£…å»å¤„ç†
- fetché»˜è®¤ä¸ä¼šå¸¦cookieï¼Œéœ€è¦æ·»åŠ é…ç½®é¡¹
- fetchä¸æ”¯æŒabortï¼Œä¸æ”¯æŒè¶…æ—¶æ§åˆ¶ï¼Œ
  - ä½¿ç”¨setTimeoutåŠPromise.rejectçš„å®ç°çš„è¶…æ—¶æ§åˆ¶å¹¶ä¸èƒ½é˜»æ­¢è¯·æ±‚è¿‡ç¨‹ç»§ç»­åœ¨åå°è¿è¡Œï¼Œé€ æˆäº†èµ„æºæµªè´¹
- fetchæ²¡æœ‰åŠæ³•åŸç”Ÿç›‘æµ‹è¯·æ±‚çš„è¿›åº¦ï¼Œè€ŒXHRå¯ä»¥

- axios
  - axios åŸºäºpromiseç”¨äºæµè§ˆå™¨å’Œnode.jsçš„httpå®¢æˆ·ç«¯ã€‚
  - åœ¨æµè§ˆå™¨ä¸­åˆ›å»º XMLHttpRequestã€‚
  - åœ¨ node.js åˆ›å»º http è¯·æ±‚ã€‚
  - æ”¯æŒ Promise APIã€‚
  - æä¾›äº†ä¸€äº›å¹¶å‘è¯·æ±‚çš„æ¥å£ï¼ˆé‡è¦ï¼Œæ–¹ä¾¿äº†å¾ˆå¤šçš„æ“ä½œï¼‰ã€‚
  - æ”¯æŒæ‹¦æˆªè¯·æ±‚å’Œå“åº”ã€‚
  - è½¬æ¢è¯·æ±‚å’Œå“åº”æ•°æ®ã€‚
  - å–æ¶ˆè¯·æ±‚ã€‚
  - è‡ªåŠ¨è½¬æ¢ JSON æ•°æ®ã€‚
  - å®¢æˆ·ç«¯æ”¯æŒé˜²æ­¢CSRFã€‚
  - å®¢æˆ·ç«¯æ”¯æŒé˜²å¾¡ XSRFã€‚
# http-range
- https://github.com/uphold/koa-pagination
  - koa-pagination is a middleware to handle Range Pagination Headers using Range & Content-Range entity-headers.

- https://github.com/academia-de-codigo/parse-content-range-header
  - Parses an HTTP Content-Range header and returns response range information.
  - allows for missing range unit for compatibility with headers generated by hapi-pagination

- more-range
  - https://github.com/expressjs/express-paginate
  - https://github.com/UlisesGascon/express-simple-pagination
  - https://github.com/purposeindustries/express-range
  - [Paginated list in Typescript (from Content-Range header)](https://gist.github.com/merlosy/1c333cf3e149ba182a7c0676a802bad8)
  - [NodeJS - Simple Pagination for Express and Sequelize](https://gist.github.com/arkanister/d2bcd2016e410e6843826e5fa7500c33)

- [Why most API paginations do not rely on HTTP Range header? - Stack Overflow](https://stackoverflow.com/questions/21765555/why-most-api-paginations-do-not-rely-on-http-range-header)
  - Most of the times you don't want to show all of your items by default. With `?p=2` style pages it's ok to reserve root `/` for first page. With "Range" header it would be strange behavior. HTTP became overbloated long time ago so I wouldn't recommend to accept every its headers as Truth.
  - Here the answers 
    - ğŸ‘‰ğŸ» è€ƒè™‘å…¼å®¹æ€§
    - First, custom units are proposed in this draft
    - Second, there is a subtle difference, the first statement has been made for parsing purpose, While the second statement has been made for producing HTTP request.
    - I conform to the HTTP spec when I'm sending [a custom range unit] and they conform to HTTP when they ignore it
    - WebDAV uses HTTP extensions correctly, IMO, but rarely works over the Internet for exactly this reason

- https://github.com/interagent/http-api-design
  - This guide describes a set of HTTP+JSON API design practices, originally extracted from work on the Heroku Platform API.
  - [Further explanation of the Range header for pagination](https://github.com/interagent/http-api-design)

- https://github.com/OpenAPITools/openapi-generator
  - allows generation of API client libraries (SDK generation), server stubs, documentation and configuration automatically given an OpenAPI Spec (v2, v3)
  - [support range header for pagination](https://github.com/OpenAPITools/openapi-generator/issues/5753)
    - Currently we are using, limit / offset query params but our api design docs call for using the header.
# [Webç«¯å³æ—¶é€šè®¯æŠ€æœ¯ç›˜ç‚¹ï¼šçŸ­è½®è¯¢ã€Cometã€Websocketã€SSE](https://zhuanlan.zhihu.com/p/21595082)

## Cometï¼šä¸€ç§hackæŠ€æœ¯

- å…¸å‹çš„Ajaxé€šä¿¡æ–¹å¼ä¹Ÿæ˜¯httpåè®®çš„ç»å…¸ä½¿ç”¨æ–¹å¼ï¼Œè¦æƒ³å–å¾—æ•°æ®ï¼Œå¿…é¡»é¦–å…ˆå‘é€è¯·æ±‚ã€‚åœ¨Low Latencyè¦æ±‚æ¯”è¾ƒé«˜çš„webåº”ç”¨ä¸­ï¼Œåªèƒ½å¢åŠ æœåŠ¡å™¨è¯·æ±‚çš„é¢‘ç‡ã€‚
- Cometåˆ™ä¸åŒï¼Œå®¢æˆ·ç«¯ä¸æœåŠ¡å™¨ç«¯ä¿æŒä¸€ä¸ªé•¿è¿æ¥ï¼Œåªæœ‰å®¢æˆ·ç«¯éœ€è¦çš„æ•°æ®æ›´æ–°æ—¶ï¼ŒæœåŠ¡å™¨æ‰ä¸»åŠ¨å°†æ•°æ®æ¨é€ç»™å®¢æˆ·ç«¯ã€‚
- Cometçš„å®ç°ä¸»è¦æœ‰ä¸¤ç§æ–¹å¼ï¼ŒåŸºäºAjaxçš„é•¿è½®è¯¢ï¼ˆlong-pollingï¼‰æ–¹å¼å’ŒåŸºäºIframeåŠhtmlfileçš„æµï¼ˆhttp streamingï¼‰æ–¹å¼ã€‚
- åœ¨ç¬¬ä¸€ç§æ–¹å¼ä¸­ï¼Œæµè§ˆå™¨åœ¨æ”¶åˆ°æ•°æ®åä¼šç›´æ¥è°ƒç”¨JSå›è°ƒå‡½æ•°ï¼Œä½†æ˜¯è¿™ç§æ–¹å¼è¯¥å¦‚ä½•å“åº”æ•°æ®å‘¢ï¼Ÿ
  - å¯ä»¥é€šè¿‡åœ¨è¿”å›æ•°æ®ä¸­åµŒå…¥JSè„šæœ¬çš„æ–¹å¼ï¼Œå¦‚`<script type="text/javascript">js_func("data from server")</script>`
  - æœåŠ¡å™¨ç«¯å°†è¿”å›çš„æ•°æ®ä½œä¸ºå›è°ƒå‡½æ•°çš„å‚æ•°ï¼Œæµè§ˆå™¨åœ¨æ”¶åˆ°æ•°æ®åå°±ä¼šæ‰§è¡Œè¿™æ®µJSè„šæœ¬ã€‚
  - ä½†æ˜¯è¿™ç§æ–¹å¼æœ‰ä¸€ä¸ªæ˜æ˜¾çš„ä¸è¶³ä¹‹å¤„ï¼šIEã€Mozilla Firefox ä¸‹ç«¯çš„è¿›åº¦æ éƒ½ä¼šæ˜¾ç¤ºåŠ è½½æ²¡æœ‰å®Œæˆï¼Œè€Œä¸”IEä¸Šæ–¹çš„å›¾æ ‡ä¼šä¸åœçš„è½¬åŠ¨ï¼Œè¡¨ç¤ºåŠ è½½æ­£åœ¨è¿›è¡Œã€‚
  - Google çš„å¤©æ‰ä»¬ä½¿ç”¨ä¸€ä¸ªç§°ä¸ºâ€œhtmlfileâ€çš„ ActiveX è§£å†³äº†åœ¨ IE ä¸­çš„åŠ è½½æ˜¾ç¤ºé—®é¢˜ï¼Œå¹¶å°†è¿™ç§æ–¹æ³•åº”ç”¨åˆ°äº† gmail+gtalk äº§å“ä¸­ã€‚

- ### [æœ‰äººç ”ç©¶è¿‡cometdçš„Bayeuxåè®®å—ï¼Ÿè¿›æ¥ä¸€èµ·ç ”ç©¶](https://www.iteye.com/topic/142310)
  - æœ€è¿‘åœ¨ç ”ç©¶cometçš„ç›¸å…³æŠ€æœ¯ï¼Œå¸Œæœ›å®ç°ä¸€ä¸ªWebIMã€‚
    - æ¯”è¾ƒçœ‹å¥½DOJOä¸‹çš„Bayeuxï¼ŒæŠ›å¼€DOJOè‡ªèº«å­˜åœ¨çš„é—®é¢˜è€Œè¨€ï¼ŒBayeuxç¡®å®æ˜¯ç¬¬ä¸€ä¸ªæ¯”è¾ƒå…¨é¢çš„å®ç°cometçš„åè®®ã€‚
    - ç‰¹åˆ«æ˜¯å¯¹long-pollingï¼Œcallback-pollingï¼Œiframeè¿™å‡ ç§cometçš„å®ç°æ‰‹æ®µéƒ½èƒ½æ”¯æŒï¼Œ
    - æˆ‘ç°åœ¨æ‰‹å¤´åªæœ‰jettyä¸­è‡ªå¸¦çš„ä¸€ä¸ªdemoå®ç°äº†Bayeuxï¼Œä¸çŸ¥é“è¿˜æœ‰æ²¡æœ‰å…¶ä»–çš„å…·ä½“ä¾‹å­ï¼Ÿ
  - é™¤äº†jettyï¼Œè¿˜æœ‰glassfishä¹Ÿå¯ä»¥ã€‚å¥½åƒæ˜¯åªæœ‰dojoå®ç°äº†Bayeuxåè®®ã€‚

## Websocketï¼šæœªæ¥çš„è§£å†³æ–¹æ¡ˆ1

- å¦‚æœè¯´Ajaxçš„å‡ºç°æ˜¯äº’è”ç½‘å‘å±•çš„å¿…ç„¶ï¼Œé‚£ä¹ˆCometæŠ€æœ¯çš„å‡ºç°åˆ™æ›´å¤šé€éœ²å‡ºä¸€ç§æ— å¥ˆï¼Œä»…ä»…ä½œä¸ºä¸€ç§hackæŠ€æœ¯ï¼Œå› ä¸ºæ²¡æœ‰æ›´å¥½çš„è§£å†³æ–¹æ¡ˆã€‚
- Cometè§£å†³çš„é—®é¢˜åº”è¯¥ç”±è°æ¥è§£å†³æ‰æ˜¯åˆç†çš„å‘¢ï¼Ÿæµè§ˆå™¨ï¼Œhtmlæ ‡å‡†ï¼Œè¿˜æ˜¯httpæ ‡å‡†ï¼Ÿ
- æœ¬è´¨ä¸Šè®²ï¼Œè¿™æ¶‰åŠåˆ°æ•°æ®ä¼ è¾“æ–¹å¼ï¼Œhttpåè®®åº”é¦–å½“å…¶å†²ï¼Œæ˜¯æ—¶å€™æ”¹å˜ä¸€ä¸‹è¿™ä¸ªæ‡’æƒ°çš„åè®®çš„è¯·æ±‚/å“åº”æ¨¡å¼äº†ã€‚ 
- W3Cç»™å‡ºäº†ç­”æ¡ˆï¼Œåœ¨æ–°ä¸€ä»£htmlæ ‡å‡†html5ä¸­æä¾›äº†ä¸€ç§æµè§ˆå™¨å’ŒæœåŠ¡å™¨é—´è¿›è¡Œå…¨åŒå·¥é€šè®¯çš„ç½‘ç»œæŠ€æœ¯Websocketã€‚
- Websocketæ˜¯ä¸€ä¸ªå…¨æ–°çš„ã€ç‹¬ç«‹çš„åè®®ï¼ŒåŸºäºTCPåè®®ï¼Œä¸httpåè®®å…¼å®¹ã€å´ä¸ä¼šèå…¥httpåè®®ï¼Œä»…ä»…ä½œä¸ºhtml5çš„ä¸€éƒ¨åˆ†ã€‚
- äºæ˜¯ä¹è„šæœ¬åˆè¢«èµ‹äºˆäº†å¦ä¸€ç§èƒ½åŠ›ï¼šå‘èµ·websocketè¯·æ±‚ã€‚
- è¿™ç§æ–¹å¼æˆ‘ä»¬åº”è¯¥å¾ˆç†Ÿæ‚‰ï¼Œå› ä¸ºAjaxå°±æ˜¯è¿™ä¹ˆåšçš„ï¼Œæ‰€ä¸åŒçš„æ˜¯ï¼ŒAjaxå‘èµ·çš„æ˜¯httpè¯·æ±‚è€Œå·²ã€‚

## SSEï¼šæœªæ¥çš„è§£å†³æ–¹æ¡ˆ2

- SSEï¼ˆServer-Sent Eventï¼ŒæœåŠ¡ç«¯æ¨é€äº‹ä»¶ï¼‰æ˜¯ä¸€ç§å…è®¸æœåŠ¡ç«¯å‘å®¢æˆ·ç«¯æ¨é€æ–°æ•°æ®çš„HTML5æŠ€æœ¯ã€‚
- ä¸ç”±å®¢æˆ·ç«¯æ¯éš”å‡ ç§’ä»æœåŠ¡ç«¯è½®è¯¢æ‹‰å–æ–°æ•°æ®ç›¸æ¯”ï¼Œè¿™æ˜¯ä¸€ç§æ›´ä¼˜çš„è§£å†³æ–¹æ¡ˆã€‚
- ä¸WebSocketç›¸æ¯”ï¼Œå®ƒä¹Ÿèƒ½ä»æœåŠ¡ç«¯å‘å®¢æˆ·ç«¯æ¨é€æ•°æ®ã€‚é‚£å¦‚ä½•å†³å®šä½ æ˜¯ç”¨SSEè¿˜æ˜¯WebSocketå‘¢ï¼Ÿ
- æ¦‚æ‹¬æ¥è¯´ï¼ŒWebSocketèƒ½åšçš„ï¼ŒSSEä¹Ÿèƒ½åšï¼Œåä¹‹äº¦ç„¶ï¼Œä½†åœ¨å®ŒæˆæŸäº›ä»»åŠ¡æ–¹é¢ï¼Œå®ƒä»¬å„æœ‰åƒç§‹ã€‚
- ä¸ªäººè®¤ä¸ºSSEæœ€å¤§çš„ä¼˜åŠ¿å°±æ˜¯ä¾¿åˆ©ï¼šä¸éœ€è¦æ·»åŠ ä»»ä½•æ–°ç»„ä»¶ï¼Œç”¨ä»»ä½•ä½ ä¹ æƒ¯çš„åç«¯è¯­è¨€å’Œæ¡†æ¶å°±èƒ½ç»§ç»­ä½¿ç”¨ã€‚
  - ä½ ä¸ç”¨ä¸ºæ–°å»ºè™šæ‹Ÿæœºã€å¼„ä¸€ä¸ªæ–°çš„IPæˆ–æ–°çš„ç«¯å£å·è€ŒåŠ³ç¥ï¼Œå°±åƒåœ¨ç°æœ‰ç½‘ç«™ä¸­æ–°å¢ä¸€ä¸ªé¡µé¢é‚£æ ·ç®€å•ã€‚æˆ‘å–œæ¬¢æŠŠè¿™ç§°ä¸ºæ—¢å­˜åŸºç¡€è®¾æ–½ä¼˜åŠ¿ã€‚
- SSEçš„ç¬¬äºŒä¸ªä¼˜åŠ¿æ˜¯æœåŠ¡ç«¯çš„ç®€æ´ã€‚
  - ç›¸å¯¹è€Œè¨€ï¼ŒWebSocketåˆ™å¾ˆå¤æ‚ï¼Œä¸å€ŸåŠ©è¾…åŠ©ç±»åº“åŸºæœ¬æä¸å®šï¼ˆæˆ‘è¯•è¿‡ï¼Œä»¤äººç—›è‹¦ï¼‰ã€‚
- å› ä¸ºSSEèƒ½åœ¨ç°æœ‰çš„HTTP/HTTPSåè®®ä¸Šè¿ä½œï¼Œæ‰€ä»¥å®ƒèƒ½ç›´æ¥è¿è¡Œäºç°æœ‰çš„ä»£ç†æœåŠ¡å™¨å’Œè®¤è¯æŠ€æœ¯ã€‚
  - è€Œå¯¹WebSocketè€Œè¨€ï¼Œä»£ç†æœåŠ¡å™¨éœ€è¦åšä¸€äº›å¼€å‘ï¼ˆæˆ–å…¶ä»–å·¥ä½œï¼‰æ‰èƒ½æ”¯æŒ
- SSEè¿˜æœ‰ä¸€ä¸ªä¼˜åŠ¿ï¼šå®ƒæ˜¯ä¸€ç§æ–‡æœ¬åè®®ï¼Œè„šæœ¬è°ƒè¯•éå¸¸å®¹æ˜“ã€‚
- WebSocketç›¸è¾ƒSSEçš„ä¸€ä¸ªæ½œåœ¨ä¼˜åŠ¿ï¼š
  - WebSocketæ˜¯äºŒè¿›åˆ¶åè®®ï¼Œè€ŒSSEæ˜¯æ–‡æœ¬åè®®ï¼ˆé€šå¸¸ä½¿ç”¨UTF-8ç¼–ç ï¼‰ã€‚
  - å½“ç„¶ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡SSEè¿æ¥ä¼ è¾“äºŒè¿›åˆ¶æ•°æ®
  - ä½†ç”¨SSEä¼ è¾“äºŒè¿›åˆ¶æ•°æ®æ—¶æ•°æ®ä¼šå˜å¤§ï¼Œå¦‚æœéœ€è¦ä»æœåŠ¡ç«¯åˆ°å®¢æˆ·ç«¯ä¼ è¾“å¤§é‡çš„äºŒè¿›åˆ¶æ•°æ®ï¼Œæœ€å¥½è¿˜æ˜¯ç”¨WebSocketã€‚
- WebSocketç›¸è¾ƒSSEæœ€å¤§çš„ä¼˜åŠ¿åœ¨äºå®ƒæ˜¯åŒå‘äº¤æµçš„ï¼Œè¿™æ„å‘³å‘æœåŠ¡ç«¯å‘é€æ•°æ®å°±åƒä»æœåŠ¡ç«¯æ¥æ”¶æ•°æ®ä¸€æ ·ç®€å•ã€‚
  - ç”¨SSEæ—¶ï¼Œä¸€èˆ¬é€šè¿‡ä¸€ä¸ªç‹¬ç«‹çš„Ajaxè¯·æ±‚ä»å®¢æˆ·ç«¯å‘æœåŠ¡ç«¯ä¼ é€æ•°æ®ã€‚
  - ç›¸å¯¹äºWebSocketï¼Œè¿™æ ·ä½¿ç”¨Ajaxä¼šå¢åŠ å¼€é”€ï¼Œä½†ä¹Ÿå°±å¤šä¸€ç‚¹ç‚¹è€Œå·²ã€‚
- å½“ä½ åœ¨äº«ç”¨SSEçš„æ—¢å­˜åŸºç¡€è®¾æ–½ä¼˜åŠ¿ï¼Œå¹¶åœ¨å®¢æˆ·ç«¯å’ŒæœåŠ¡ç«¯è„šæœ¬ä¹‹é—´è®¾äº†ä¸€ä¸ªç½‘ç»œæœåŠ¡å™¨ï¼ŒåŒºåˆ«å°±æ˜¾ç°å‡ºæ¥äº†ã€‚
  - ä¸€ä¸ªSSEè¿æ¥ä¸ä»…ä½¿ç”¨ä¸€ä¸ªå¥—æ¥å­—ï¼Œè¿˜ä¼šå ç”¨ä¸€ä¸ªApacheçº¿ç¨‹æˆ–è¿›ç¨‹ï¼Œå¦‚æœç”¨PHPï¼Œå®ƒä¼šä¸ºè¿™ä¸ªè¿æ¥ä¸“é—¨åˆ›å»ºä¸€ä¸ªPHPæ–°å®ä¾‹ã€‚
  - Apacheå’ŒPHPä¼šä½¿ç”¨å¤§é‡çš„å†…å­˜ï¼Œè¿™ä¼šé™åˆ¶æœåŠ¡å™¨æ‰€èƒ½æ”¯æŒçš„å¹¶è¡Œè¿æ¥æ•°ã€‚
  - æ‰€ä»¥ï¼Œè¦åšåˆ°ç”¨SSEåœ¨æ•°æ®ä¼ è¾“æ€§èƒ½ä¸Šå’ŒWebSocketå®Œå…¨ä¸€æ ·ï¼Œéœ€è¦å†™ä¸€ä¸ªè‡ªå·±çš„åç«¯æœåŠ¡å™¨

- ref
  - [ä¸ºä»€ä¹ˆç½‘é¡µç‰ˆå¾®ä¿¡/QQï¼ŒGTalkçš„IMé€šè®¯ç”¨çš„éƒ½æ˜¯cometé•¿è¿æ¥è€Œä¸ç”¨websocketï¼Ÿ](https://www.zhihu.com/question/350007333)
# blog

## [PUT vs PATCH & PUT vs POST - DEV Community](https://dev.to/mehmehmehlol/put-vs-patch-put-vs-post-56i9)

- PUT vs POST
  - The most obvious difference is that PUT can both create and modify a resource while POST can only create a resource.
  - The PUT method is idempotent. Meaning if you (re)try to send a request multiple times, this is equivalent to a single request modification.
  - Whereas, the POST method is NOT idempotent. If you retry to send a request multiple times, you will end up having multiple resources with multiple different URIs on the server.
  - Generally, PUT method is used for UPDATE operations while the POST method is used for the CREATE operations.

- PUT vs PATCH
  - PUT and PATCH can both be used for updating resources. However, the biggest difference between these two is that one can update and replace the resource while the other one can update partially.
  - In other words, when making a PUT request, the enclosed entity is viewed as the modified version of the resource, and the client is requesting to replace with the new info; when making a PATCH request, it modifies only some part of the resource.
  - PUT is idempotent, while PATCH is not idempotent. If a request is reattempted to be made, it will result a failed request (Method Not Allowed). If a PATCH request is made to a non-existent URI, it would simply fail without creating a new resource like PUT.

## Why I still use XHR instead of the Fetch API

- [Why I still use XHR instead of the Fetch API_2018](https://gomakethings.com/why-i-still-use-xhr-instead-of-the-fetch-api/)

- UPDATE: Iâ€™ve completely changed my mind on this. Iâ€™m now all-in on fetch()

## How to use the Fetch API with vanilla JS

- [How to use the Fetch API with vanilla JS](https://gomakethings.com/how-to-use-the-fetch-api-with-vanilla-js/)

## âš–ï¸ [The Bayeux Protocol Specification 1.0](https://docs.cometd.org/current/reference/index.html#_bayeux)

- Bayeux is a protocol for transporting asynchronous messages (primarily over web protocols such as HTTP and WebSocket), with low latency between a web server and web clients.
- The primary purpose of Bayeux is to support responsive bidirectional interactions between web clients, for example using using AJAX, and the web server.
- Bayeux is a protocol for transporting asynchronous messages (primarily over HTTP), with low latency between a web server and a web client. 
- The messages are routed via named channels and can be delivered:
  - server to client
  - client to server
  - client to client (via the server)
- By default, publish/subscribe routing semantics are applied to the channels.
- Delivery of asynchronous messages from the server to a web client is often described as server push. 
- The combination of server push techniques with an AJAX web application has been called **Comet**. 
- CometD is a project by the Dojo Foundation to provide multiple implementation of the Bayeux protocol in several programming languages.
- Bayeux seeks to reduce the complexity of developing Comet web applications by allowing implementers to more easily interoperate, 
  - to solve common message distribution and routing problems, 
  - and to provide mechanisms for incremental improvements and extensions.

- [Difference between async servlet long poll and bayeux protocol (Comet)](https://stackoverflow.com/questions/14268606/difference-between-async-servlet-long-poll-and-bayeux-protocol-comet)
  - It is true that "Comet" is the term for these technologies, but the Bayeux protocol is used only by few implementations. 
  - A Comet technique can use any protocol it wants; Bayeux is one of them.
  - there are two main differences between an async servlet solution and a Comet+Bayeux solution.
  - The first difference is that the Comet+Bayeux solution is independent of the protocol that transports Bayeux. 
    - In the CometD project, there are pluggable transports for both clients and servers that can carry Bayeux. 
    - You can carry it using HTTP, with Bayeux being the content of a POST request, 
    - but you can also carry it using WebSocket, with Bayeux being the payload of the WebSocket message. 
    - If you use async servlets, you cannot leverage WebSocket, which is way more efficient than HTTP.
  - The second difference is that async servlets only carry HTTP, and you need more than that to handle remote Comet clients.
    - Quickly you realize that you're building another protocol on top of HTTP.
    - At that point, it's better to reuse an existing protocol like Bayeux, and proven solutions like CometD
# more
- [AsyncAPI 2.0: Enabling the Event-Driven World_202105](https://tech.ebayinc.com/engineering/asyncapi-2-0-enabling-the-event-driven-world/)
  - Learn about how eBay is standardizing on and publishing AsyncAPI Specification 2.0-based contracts for event notifications.
# discuss-http2
- ## 

- ## My favorite HTTP/2 feature is Connection Coalescing.
- https://twitter.com/iamakulov/status/1731629685094920349
  - In HTTP2, normally, a browser opens a new connection for every new domain it sees. (So if your site loads via www. but serves images from img., thatâ€™d be 2 connections.)
  - Making domains use the same IP address and HTTPS certificate is an *implicit* way to enable connection coalescing; the control is on the browserâ€™s side, and itâ€™s not always great. (Plus sharing IPs is tricky.) But (TIL!) thereâ€™s also an *explicit* way.

# discuss-stream
- ## 

- ## 

- ## ğŸŒ° Implementing basic HTML streaming with node
- https://x.com/asidorenko_/status/1857475654364655751
- PHP days all over again

# discuss-polling
- ## 

- ## 

- ## 

- ## æœ€è¿‘æŠŠä¸€ä¸ª polling based çš„ä»»åŠ¡è°ƒåº¦ç³»ç»Ÿæ”¹é€ æˆ push basedï¼Œè§‚å¯Ÿåˆ° scheduling delay ä»åˆ†é’Ÿçº§åˆ«é™åˆ°åˆ°äº†æ¯«ç§’çº§åˆ«
- https://x.com/_foreverbell/status/1819003908083400923
- è¢«æ‹’ç»äº†å—ï¼Ÿç­”ï¼špolling basedä¹Ÿå¤Ÿç”¨äº†
- è¦æ˜¯æˆ‘å°±ç›´æ¥æŠŠ poll é—´éš”æ”¹çŸ­ç‚¹ 
  - åº•å±‚å­˜ event çš„ storage å‹åŠ›ä¼šå¾ˆå¤§
- åº•å±‚ event sourcer ç³»ç»Ÿ bookkeeping message çš„æˆæœ¬ä¼šä¸Šå»ï¼Œä¸è¿‡æ¯”èµ·è½®è¯¢å¯¹ç³»ç»Ÿé€ æˆçš„å‹åŠ›æ¥è¯´ï¼Œè¿™ä¸ªä»£ä»·åŸºæœ¬ä¸Šç®—æ˜¯ net win 

# discuss
- ## 

- ## 

- ## 

- ## node-fetch-server Write servers for Node.js using the web fetch API primitives, like Request and Response
- https://x.com/mjackson/status/1831746987517264056
  - The main API is a createRequestListener() function you can use to create a http. RequestListener that seamlessly integrates with http.createServer() and https.createServer().
  - You can use this to power your Remix app *today* if you arenâ€™t using any special features of Express
  - This is how the web evolves. The people who wrote the spec weren't thinking about server applications for it, but it happened. And now that it has (and we're not going back) it'll improve and adapt.
- I have been saying this for years, this needs to be added to nodejs itself. Looks promising really nice job !
  - There's an effort in the Node.js committee to redesign the http module. I believe that will include the way servers are created. Fingers crossed!
- Very nice. If you still need advanced APIs (express like) use hono instead. Still all web APIs are there.
  - I wish that were true, but they have a bunch of bespoke APIs as well like: request.headers is not a Headers object, but a function you use to get headers (like request.headers('content-type') for example).

- ## [å›½å†… dns è§£æå›½å¤–åŸŸåç«Ÿç„¶è¿™ä¹ˆæ…¢ - V2EX _202409](https://v2ex.com/t/1069396)
  - æœ¬æ¥ç”¨çš„ AdGuardHome ç™½åå•æ¨¡å¼åˆ†æµå›½å†…å¤–åŸŸåï¼Œè…¾è®¯ç³»åŸŸåç”¨çš„ dnspod ï¼Œå›½å†…å…¶ä»–åŸŸåç”¨çš„ alidns ï¼Œå…¶ä»–åŸŸåç”¨çš„ quad9 ã€cloudflare ã€opendns ç­‰å›½å¤– dns ï¼Œä»Šå¤©çªç„¶æ”¹æˆé»‘åå•æ¨¡å¼ï¼Œå°‘æ•°åŸŸåç”¨å›½å¤– dns ï¼Œå‰©ä¸‹çš„è…¾è®¯ç³»ç»§ç»­ç”¨ dnspod ï¼Œå…¶ä»–çš„éƒ½ç”¨ alidns ã€‚
  - ç»“æœå‘ç°æ‰“å¼€å¾ˆå¤šå›½å¤–ç½‘ç«™ç‰¹åˆ«æ…¢ï¼Œä¸€çœ‹æŸ¥è¯¢æ—¥å¿—ï¼ŒåŸæ¥ alidns è§£æå¾ˆå¤šå›½å¤–åŸŸåéƒ½æ˜¯ 1000ms+ï¼Œè¿™ä¸æ…¢æ‰æ€ªäº†ï¼Œçœ‹æ¥è¿˜æ˜¯ç™½åå•æ¨¡å¼æ›´é€‚åˆï¼Œè™½ç„¶ä¼šå­˜åœ¨éƒ¨åˆ†é”™æ€ï¼ˆéƒ¨åˆ†å›½å†…åŸŸåç”±äºç”¨äº†é»˜è®¤çš„å›½å¤– dns è§£æåˆ°äº†éæœ€ä¼˜çš„å›½å†… ip ä¸Šï¼‰ã€‚
  - ä»¥å‰æ˜¯çœŸæ²¡æƒ³åˆ°å›½å†… dns è§£æå›½å¤–åŸŸåæ¯”ç›´æ¥ä»å›½å¤– dns è§£æè¿˜æ…¢çš„ï¼Œè®¿é—®å¤šå¤– dns å¤šå‡ºé‚£å‡ åä¸Šç™¾ ms è·Ÿå›½å†… dns è§£ææ…¢çš„ä¸Šåƒ ms æ¯”èµ·æ¥çœŸä¸ç®—å•¥

- åˆ«æŠ˜è…¾äº†, å›½å†…ç›´æ¥èµ°è¿è¥å•†çš„æ‹‰åˆ°äº†ï¼Œå›½å¤–èµ° 8888 å’Œ 1111 ï¼Œå®Œäº‹
  - å…³é”®é—®é¢˜æ˜¯ä½ å¦‚ä½•èƒ½ç¡®å®šå®Œæ•´çš„å›½å†…åŸŸååå•ï¼Ÿå¦‚æœèƒ½æœ‰å…¨åå•ï¼Œé‚£æˆ‘é™¤å›½å†…åŸŸåå¤–çš„å…¶ä»–åŸŸåèµ°å›½å¤– dns å°±ç®€å•äº†ã€‚è€Œä¸”è¿è¥å•† dns æœ‰ä¸ªæŒºè‡´å‘½çš„é—®é¢˜ï¼ŒHTTPS è§£æï¼Œä¹Ÿå°±æ˜¯ type 65 è¦ä¹ˆæ²¡ç»“æœï¼Œè¦ä¹ˆå°±æ˜¯é”™çš„ï¼Œè¿™ç®—æ˜¯æˆ‘å›½å†…ç”¨ alidns æœ€å¤§çš„åŸå› å§ï¼Œå½“ç„¶æˆéƒ½ç”µä¿¡ alidns çš„é€Ÿåº¦æœ¬æ¥ä¹Ÿå°±è·Ÿç”µä¿¡ dns å·®ä¸å¤šï¼Œ5ms å·¦å³å§

- ä½ ä¸ç”¨ AdGuardHome è¿™ç§è½¯ä»¶ä¼°è®¡å¯¹è‡ªå·±ä¸€å¤©çš„ dns è§£ææ•°é‡æ²¡å¤ªå¤§æ¦‚å¿µï¼Œæˆ‘ä¹Ÿæ˜¯ç”¨äº†ä¹‹åæ‰å¤§åƒä¸€æƒŠï¼Œæˆ‘ä¸€ä¸ªäººåœ¨å®¶çš„æ—¶å€™ä¸€å¤©çš„è§£æé‡å°±æœ‰ 5w å·¦å³å§ï¼Œè¿™è¿˜æ˜¯æ²¡å¼€å±è”½çš„æƒ…å†µä¸‹ï¼Œå¦‚æœå¼€äº†å±è”½ä¼šçªœåˆ°å°†è¿‘ 10W ï¼ˆæœ‰äº› app åœ¨å¾—ä¸åˆ°ç›¸åº”çš„æƒ…å†µä¸‹ä¼šé‡å¤è¯·æ±‚ï¼‰ã€‚è™½ç„¶è¿™å…¶ä¸­ç»å¤§å¤šæ•°æ˜¯é‡å¤çš„ï¼Œä½†å…¶ä¸­ä¸é‡å¤çš„ä¹Ÿæœ‰å‡ ç™¾ä¸Šåƒä¸ªåŸŸåå§ï¼Œå¾ˆå¤š app å’Œç½‘ç«™ä¸€æ‰“å¼€å°±ä¼šè¯·æ±‚ä¸¤ä½æ•°åŸŸåçš„ã€‚

- alidns å’Œ dnspod å¼€å§‹é™é€Ÿäº†ä½ å±…ç„¶ä¸çŸ¥é“ï¼Œç°åœ¨åªæ”¯æŒä¸ªäººä½¿ç”¨ï¼Œå®¶é‡Œè®¾å¤‡ä¸€å¤šè¯·æ±‚é€Ÿä¸Šæ¥ä¸å¡æ‰æ€ªå˜ã€‚
  - æˆ‘å½“ç„¶çŸ¥é“è¦å¼€å§‹é™é€Ÿäº†ï¼Œä¸è¿‡ä¸æ˜¯è¿˜æ²¡å¼€å§‹å—ï¼Œè€Œä¸”æˆ‘é™¤äº†ç”¨å…¬å…±çš„å¤–ï¼Œè¿˜éƒ½ç”¨äº†ä¸ªäººè´¦æˆ·çš„ï¼Œå¹¶ä¸æ˜¯è¿™ä¸ªåŸå› ï¼Œåº”è¯¥æ˜¯å›½å¤–åŸŸååœ¨ alidns å’Œ dnspod æœåŠ¡å™¨ä¸Šæ²¡ç¼“å­˜ï¼Œå¯¼è‡´è®¿é—®ç¼“æ…¢

- ## It seems that `fetch` , and by extension all browsers, only support "half duplex" streaming. 
- https://twitter.com/BenLesh/status/1761092192242729125
  - Meaning you can stream the request to the server, but you can't simultaneously stream the response back.
- I think the web is ready for a new API. Observables support this time
  - There's already the WebTransport API, which is http/3. But that's not supported everywhere yet. In particular, I don't think Node supports it yet (but I'm unsure).

- Presumably a WebSocket would work here?
  - Yup. But then Iâ€™m hand-rolling multiplexing logic on both ends or using some bloated library.

- It's indeed implied by HTTP protocol which is half-duplex. Websockets allow to upgrade the connection to fullduplex.

- ## ğŸ†šï¸ Is there any reason to use axios in environments where fetch is available? Other than familiarity.
- https://twitter.com/mattpocockuk/status/1758552616500445329

- [You may not need Axios - Dan Levy's Programming Blog](https://danlevy.net/you-may-not-need-axios/)

- I think Axios can abort a request?
  - Fetch can too, using AbortSignal
- Axios DOES NOT use fetch. (last I checked)
  - In browsers, it uses `XMLHttpRequest` .
  - In Node, it uses the builtin modules `http` & `https` .
- Here's the feature comparison table.  Fetch can do virtually anything Axios can.

- Mostly no, but there are a few use cases like nice defaults, interceptors, retrys, caching. Most of this could be built with a lightweight abstraction on top of fetch, but there are reasons people havenâ€™t moved off. 

- The interface is nice. `const { data, headers, status } = await axios.get<User>('/user')`. This takes a lot more effort with fetch. Still, I think I would use a simple fetch wrapper for new projects.
- But do you really call axios/fetch directly? In my case itâ€™s always inside a service that check status for auth stuff anyway
  - Not all APIs need authentication. Also you can authenticate using Axios interceptors, or cookies.
- the generic is the problem here, interface is actually decent to destructure. fetch wrapper is cheaper and doesnâ€™t use xmlhttprequest

- ky ( @sindresorhus ) and ofetch ( @unjsio ) are both excellent modern fetch wrappers

- axios has cool extras like interceptors, JSON parsing, and better error handling.

- Interceptors. It allows me to automatically assign auth tokens on each request and. Also if you have a global loader in the application you can automatically toggle that on each request

- There are some advantages, I've made good use of axios's interceptor system for tagging on auth and stuff like that

- we use axios between our services internally because you can add interceptors to make axios aware of cache headers. It means that internal HTTP endpoints can be set up with the same type of cache headers as external ones, and you don't have to think about two different types of endpoint response caching depending on where the request came from

- Fetch doesnâ€™t throw on 400/500 so you have to write your own wrapper or rewrite it every place you use fetch. 
  - Axios has a lot of other nice-to-haves too, like base href and interceptors. 
  - I went all fetch then went back to axios

- When using fetch, we end up creating a wrapper around it to do basic things, like: 
  - Parsing the body
  - Throwing errors
  - Insert interceptors
  - Set global default headers config
- interceptors
- instances with common configuration
  - base URL
  - Auth header
  - serialization of search params from JSON
  - serialization of URL params - which is not built-in, but doable using instance configuration
- automatic parse to and from JSON
- Default Headers / Cookies
- Upload Percentage
- Not 32 awaits to get a response
- Throws error on error status codes

- Any project I use fetch in, I end up writing a wrapper that handles errors, converts body to json, simplifies setting headers. Axios does this out of the box. So it is in some ways the better option.

- Axios automatically treats non-2xx responses as errors, which is a nice convenience. But writing a fetch wrapper to do that is trivial.

- ğŸ’¡ I love fetch and have switched over to it but there are some caveats worth knowing:
  - It doesn't support HTTP/1.1 chunked transfer encoding (ajax does). So if you want to upload a stream of data that you don't know the size of then you're forced to use HTTP/2 and set the duplex: 'half'. Support for all of that is mixed.
  - There are no progress events. Imagine uploading a large file and wanting to show percent uploaded indicator or progress bar. Can't be done right now afaict.
  - In Node.js (undici), ReadableStream and fetch are way slower than built-in http client. However, these will catch up in time.
  - A lot of folks, myself included, can cope with these restrictions though.

- Consider axios only if your project benefits from features like global error handling or progress tracking, which are more straightforward with axios.

- If you build isomorphic web apps, use an LTS version of Node, and donâ€™t use experimental APIs, then you canâ€™t use fetch. It became stable in Node 21.

- ## What made HTTP/1.1 so popular? It was launched in 1997. 
- https://twitter.com/ProgressiveCod2/status/1736330988807152063
  - Persistent Connections. The connection isn't closed immediately after the server sends the response to the client. The client can send additional requests over the same TCP connection.
  - Pipelining. Pipelining allows multiple requests to be sent to the server without waiting for the corresponding response.
  - But there are limits to the number of concurrent TCP connections.

- the 3-way handshake is indeed a foundational aspect of TCP.
  - With HTTP/3, they are going away from TCP to QUIC.

- ## HTTP verbs: I agree there should be only GET and POST.
- https://twitter.com/diegohaz/status/1717196146232246280
  - The issue is that we already have a well-established convention around HTTP verbs, which simplifies the process of building and consuming REST APIs.
  - What if we POST everything? /things/create, /create-thing, /things/id/delete? Or perhaps /delete-thing with the ID included in the body? At this point, it seems too arbitrary.

- ## Here's a wrapper around `fetch()` that validates the response body against a zod schema.
- https://twitter.com/gimenete/status/1688297547243077632
  - I use it when I need to use a 3rd party API and using their SDK would be overkill, or there's no SDK or the SDK is Node-only and I'm on Cloudflare workers.
  - [A wrapper around the fetch function that validates the response body against a Zod schema](https://gist.github.com/gimenete/dd1886288ee3d3baaeae573ca226048f)

- ## [æµè§ˆå™¨å…è®¸çš„å¹¶å‘è¯·æ±‚èµ„æºæ•°æ˜¯ä»€ä¹ˆæ„æ€ï¼Ÿ - çŸ¥ä¹](https://www.zhihu.com/question/20474326)
- é¦–å…ˆï¼Œæ˜¯åŸºäºç«¯å£æ•°é‡å’Œçº¿ç¨‹åˆ‡æ¢å¼€é”€çš„è€ƒè™‘ï¼Œæµè§ˆå™¨ä¸å¯èƒ½æ— é™é‡çš„å¹¶å‘è¯·æ±‚ï¼Œå› æ­¤è¡ç”Ÿå‡ºæ¥äº†å¹¶å‘é™åˆ¶å’ŒHTTP/1.1çš„Keep aliveã€‚
  - è€Œéšç€æŠ€æœ¯çš„å‘å±•ï¼Œè´Ÿè½½å‡è¡¡å’Œå„ç±»NoSQLçš„å¤§é‡åº”ç”¨ï¼ŒåŸºæœ¬å·²ç»è¶³ä»¥åº”å¯¹C10Kçš„é—®é¢˜ã€‚ 
  - ä½†å´å¹¶ä¸æ˜¯æ¯ä¸ªç½‘ç«™éƒ½æ‡‚å¾—åˆ©ç”¨domain hashä¹Ÿå°±æ˜¯å¤šåŸŸåæ¥åŠ é€Ÿè®¿é—®ã€‚
  - å› æ­¤ï¼Œæ–°çš„æµè§ˆå™¨åŠ å¤§äº†å¹¶å‘æ•°çš„é™åˆ¶ï¼Œä½†å´ä»æ§åˆ¶åœ¨8ä»¥å†…ã€‚

- è¡¥å……ä¸€å°ç‚¹å°±æ˜¯æµè§ˆå™¨å³ä½¿æ”¾å¼ƒä¿æŠ¤è‡ªå·±ï¼Œå°†æ‰€æœ‰è¯·æ±‚ä¸€èµ·å‘ç»™æœåŠ¡å™¨ï¼Œä¹Ÿå¾ˆå¯èƒ½ä¼šå¼•å‘æœåŠ¡å™¨çš„å¹¶å‘é˜ˆå€¼æ§åˆ¶è€Œè¢«BANï¼Œè€Œå¦å¤–ä¸€ä¸ªæ§åˆ¶åœ¨8ä»¥å†…çš„åŸå› ä¹Ÿæ˜¯keep aliveæŠ€æœ¯çš„å­˜åœ¨ä½¿å¾—æµè§ˆå™¨å¤ç”¨ç°æœ‰è¿æ¥å’ŒæœåŠ¡å™¨é€šä¿¡æ¯”åˆ›å»ºæ–°è¿æ¥çš„æ€§èƒ½è¦æ›´å¥½ä¸€äº›ã€‚

- æµè§ˆå™¨çš„å¹¶å‘è¯·æ±‚æ•°ç›®é™åˆ¶æ˜¯é’ˆå¯¹åŒä¸€åŸŸåçš„ã€‚
  - åŒä¸€æ—¶é—´é’ˆå¯¹åŒä¸€åŸŸåä¸‹çš„è¯·æ±‚æœ‰ä¸€å®šæ•°é‡é™åˆ¶ã€‚
  - è¶…è¿‡é™åˆ¶æ•°ç›®çš„è¯·æ±‚ä¼šè¢«é˜»å¡ï¼Œè¿™å°±æ˜¯ä¸ºä»€ä¹ˆä¼šæœ‰zhimg.com, http://twimg.com ä¹‹ç±»åŸŸåçš„åŸå› ã€‚

- åŠå¼€è¿æ¥æŒ‡çš„æ˜¯ TCP è¿æ¥çš„ä¸€ç§çŠ¶æ€ï¼Œå½“å®¢æˆ·ç«¯å‘æœåŠ¡å™¨ç«¯å‘å‡ºä¸€ä¸ª TCP è¿æ¥è¯·æ±‚ï¼Œåœ¨å®¢æˆ·ç«¯è¿˜æ²¡æ”¶åˆ°æœåŠ¡å™¨ç«¯çš„å›åº”å¹¶å‘å›ä¸€ä¸ªç¡®è®¤çš„æ•°æ®åŒ…æ—¶ï¼Œè¿™ä¸ª TCP è¿æ¥å°±æ˜¯ä¸€ä¸ªåŠå¼€è¿æ¥ã€‚
  - è‹¥æœåŠ¡å™¨åˆ°è¶…æ—¶ä»¥åä»æ— å“åº”ï¼Œé‚£ä¹ˆè¿™ä¸ª TCP è¿æ¥å°±ç­‰äºç™½è´¹äº†ï¼Œæ‰€ä»¥æ“ä½œç³»ç»Ÿä¼šæœ¬èƒ½çš„ä¿æŠ¤è‡ªå·±ï¼Œé™åˆ¶ TCP åŠå¼€è¿æ¥çš„æ€»ä¸ªæ•°ï¼Œä»¥å…æœ‰é™çš„å†…æ ¸æ€å†…å­˜ç©ºé—´è¢«ç»´æŠ¤ TCP è¿æ¥æ‰€éœ€çš„å†…å­˜æ‰€æµªè´¹ã€‚

- ç”±äº TCP åè®®çš„é™åˆ¶ï¼ŒPC ç«¯åªæœ‰65536ä¸ªç«¯å£å¯ç”¨ä»¥å‘å¤–éƒ¨å‘å‡ºè¿æ¥ï¼Œè€Œæ“ä½œç³»ç»Ÿå¯¹åŠå¼€è¿æ¥æ•°ä¹Ÿæœ‰é™åˆ¶ä»¥ä¿æŠ¤æ“ä½œç³»ç»Ÿçš„ TCP\IP åè®®æ ˆèµ„æºä¸è¢«è¿…é€Ÿè€—å°½ï¼Œå› æ­¤æµè§ˆå™¨ä¸å¥½å‘å‡ºå¤ªå¤šçš„ TCP è¿æ¥ï¼Œè€Œæ˜¯é‡‡å–ç”¨å®Œäº†ä¹‹åå†é‡å¤åˆ©ç”¨ TCP è¿æ¥æˆ–è€…å¹²è„†é‡æ–°å»ºç«‹ TCP è¿æ¥çš„æ–¹æ³•ã€‚
- å¦‚æœé‡‡ç”¨é˜»å¡çš„å¥—æ¥å­—æ¨¡å‹æ¥å»ºç«‹è¿æ¥ï¼ŒåŒæ—¶å‘å‡ºå¤šä¸ªè¿æ¥ä¼šå¯¼è‡´æµè§ˆå™¨ä¸å¾—ä¸å¤šå¼€å‡ ä¸ªçº¿ç¨‹ï¼Œè€Œçº¿ç¨‹æœ‰æ—¶å€™ç®—ä¸å¾—æ˜¯è½»é‡çº§èµ„æºï¼Œæ¯•ç«Ÿåšä¸€æ¬¡ä¸Šä¸‹æ–‡åˆ‡æ¢å¼€é”€ä¸å°ã€‚
- è¿™æ˜¯æµè§ˆå™¨ä½œä¸ºä¸€ä¸ªæœ‰è‰¯çŸ¥çš„å®¢æˆ·ç«¯åœ¨ä¿æŠ¤æœåŠ¡å™¨ã€‚å°±åƒä»¥å¤ªç½‘çš„å†²çªæ£€æµ‹æœºåˆ¶ï¼Œå®¢æˆ·ç«¯åœ¨ä½¿ç”¨å…¬å…±èµ„æºçš„æ—¶å€™å¿…é¡»è¦è‡ªè¡Œå†³å®šä¸€ä¸ªç­‰å¾…æœŸã€‚å½“è¶…è¿‡2ä¸ªå®¢æˆ·ç«¯è¦ä½¿ç”¨å…¬å…±èµ„æºæ—¶ï¼Œå¼ºåŠ¿çš„é‚£ä¸ªé‚ªæ¶çš„å®¢æˆ·ç«¯å¯èƒ½ä¼šå¯¼è‡´å¼±åŠ¿çš„å®¢æˆ·ç«¯å®Œå…¨æ— æ³•è®¿é—®å…¬å…±èµ„æºã€‚ä»å‰è¿…é›·è¢«å–·å°±æ˜¯å› ä¸ºå®ƒä¸æ˜¯ä¸€ä¸ªæœ‰è‰¯çŸ¥çš„å®¢æˆ·ç«¯ï¼Œå®ƒä½œä¸º HTTP åè®®å®¢æˆ·ç«¯æ²¡æœ‰è€ƒè™‘åˆ°æœåŠ¡å™¨çš„å‹åŠ›ï¼Œä½œä¸º BT å®¢æˆ·ç«¯æ²¡æœ‰è€ƒè™‘åˆ°è‡ªå·±å›é¦ˆä¸Šä¼ é‡çš„ä¹‰åŠ¡ã€‚

- ## äº‰è®®: We will very likely be removing the onSuccess / onError / onSettled callbacks from `useQuery` in v5. 
- https://twitter.com/TkDodo/status/1647347026135330816
  - I tried very hard to come up with a good use-case, but imo there is none.
- I use them to span toast of a success or error event, find them super useful
  - This would show the toast multiple times if you call the same hook in multiple components, so it's likely not what you want. The global callbacks on the QueryCache are better suited for toast notifications
- I put logging and trigger snackbars alerts in onError. Guess it can be in a useEffect, but doesn't seem as clean.
  - should probably both be in the global queryCache callback so that you a) only have to set it up once and b) it doesn't trigger multiple times.
  - in mobile apps there are lot of cases where we need to handle every error differently. having it setup once will not be suitable for this case.
  - depends on what handling it differently means. I've had a good experience with the global callbacks + the meta field

- ## [OData adoption rate? : dotnet](https://www.reddit.com/r/dotnet/comments/11eoa6d/odata_adoption_rate/)

- ## æ¢ä¸ªè§’åº¦æƒ³æƒ³ï¼Œ#GraphQL å¥½åƒæ˜¯åŒèµ¢ã€‚
- https://twitter.com/lovedebug/status/1646680811402584066
- æˆ‘è§‰å¾—è¿˜æŒºå¥½ç»´æŠ¤çš„ï¼Œä¹ æƒ¯äº†å°±å¥½äº†ã€‚
  - ä¹ æƒ¯äº† REST ï¼Œè§‰å¾— GraphQL çº¦æŸå¤ªå¤šï¼Œè¿˜è¦æå‰å®šä¹‰ç±»å‹å’Œæ•°æ®ç»“æ„ã€‚
  - ä¹ æƒ¯äº†GraphQLï¼Œè§‰å¾— REST å¤ªéšæ„ï¼Œä¸çœ‹æ–‡æ¡£è¿å‚æ•°å’Œè¿”å›å€¼æ˜¯ä»€ä¹ˆéƒ½ä¸çŸ¥é“ã€‚
  - åªè¦æ€ç»´è½¬å˜äº†ï¼Œæ‰‹ä¸Šçš„æ´»åªæ˜¯è‚Œè‚‰è®°å¿†è€Œå·²ã€‚
- å…¶å® REST çš„å‡ ä¸ªææ¡ˆä¹Ÿè§£å†³äº†æŸ¥å‚æ•°å’Œè¿”å›å€¼çš„é—®é¢˜ï¼Œæ¯”å¦‚ odata, HAL ç­‰ï¼Œå¯æƒœå¼€æºçš„åç«¯å®ç°ä¸å¥½æ‰¾

- ## Which library should I use for fetching data in React?
- https://twitter.com/shashwatnauti/status/1622901075648061440
  - Tha lack of "automatic garbage collection" in SWR is an important issue for me.
- Depending on if you're planning to do some advanced cache management, mutations.
  - My rule of thumb: simply fetching - SWR. It's gotten better at mutations but not quite.
  - If your use-case is beyond "get the data, show it's status, display the data", you might want to look into RQ

- ## Fetch data from an api in useEffect or in event handler directly in react
- https://stackoverflow.com/questions/62277013/
- It depend on your usecase
- fetching data in useEffect is useful in following scenarios
  - Fetching data during some lifecycles like initial render
  - Fetching data when some prop changes
  - fetching data in an interval but setting up a subscription or setInterval
- Fetching data in handler is useful
  - Based on a user interaction such as search button click, search input change
- I would say you should go with the hooks implementation. 
  - It's recommended in the React docs for performing side effects
  - Data fetching, setting up a subscription, and manually changing the DOM in React components are all examples of side effects. 

- ## How to send request on click React Hooks way?
- https://stackoverflow.com/questions/55647287
- why would you prefer using useCallback instead of useEffect? 
  - Well, because it's a callback and not a side-effect
  - well, depends on how you treat it. if you use reactive/declarative way, it can be sideEffect. if you use imperative way, it can be a callback. both work. 
  - I wouldn't recommend using useEffect. To do that, it would become an effect triggered by a state-change, which would also cause an unnecessary re-render. Callbacks are inherently side-effects when they are triggered by a user-action
- You don't need an effect to send a request on button click, instead what you need is just a handler method which you can optimise using `useCallback` method
  - Tracking request using variable with `useEffect` is not a correct pattern because you may set state to call api using `useEffect` , but an additional render due to some other change will **cause the request to go in a loop**
- In functional programming, any async function should be considered as a side effect.
  - When dealing with side effects you need to separate the logic of starting the side effect and the logic of the result of that side effect (similar to redux saga).
  - Basically, the button responsibility is only triggering the side effect, and the side effect responsibility is to update the dom.
  - It's always better to separate the logic of your side effect from the logic that triggers the effect (the useEffect)

- ## React Hooks API call - does it have to be inside useEffect?
- https://stackoverflow.com/questions/61348598
  - I wanted to ask if every single API call we make has to be inside the useEffect hook?
  - my data fetching actually takes place in a function run on a button click and not in the useEffect itself. It seems to be working.
- Yes, apis calls that happen on an action like button click will not be part of `useEffect` call. It will be part of your event handler function.
  - When you call useEffect, youâ€™re telling React to run your â€œeffectâ€ function after flushing changes to the DOM
  - Note: You should always write async logic inside useEffect if it is not invoked by an event handler function.
- Yes, you can make api requests in an event handler such as onClick.

- ## Performance is a top priority of SWR.
- https://twitter.com/shuding_/status/1324405638986788864
- why and how SWR ensures your app to be always fast and reactive:
  âœ… No extra requests
  âœ… No extra re-renders
  âœ… No extra code imported
- If only the server-side prefetcher were as good as the one in React Query, I would definitely think about switching to SWR
- Nice - Is it doing a fetch request within a useEffect hook under the hood?

- ## TIL: no way to fetch huge (2GB+) files, and XHR on readyState 3 is hopeless too (it keeps incrementing responseText even if consumed).
- https://twitter.com/WebReflection/status/1395733097187090442
- If youâ€™re wondering the use case: CSV files is just one of them, and you gotta be smart about lines split, but it works after all and itâ€™s the best solution we have
- [Streaming requests with the fetch API](https://web.dev/fetch-upload-streaming/)
- Chrome 85 has an experimental implementation of request streams, 
  - meaning you can start making a request before you have the whole body available.
- usecase
  - Warm up the server. 

    - In other words, you could start the request once the user focuses a text input field, and get all of the headers out of the way, then wait until the user presses 'send' before sending the data they entered.

  - Gradually send data generated on the client, such as audio, video, or input data.
  - Recreate web sockets over HTTP.

- ## I've just included Undici as the best way for fetching data on the server-side in my "Real-World Next.js" book. 
- https://twitter.com/MicheleRivaCode/status/1386357676540579844
- https://github.com/nodejs/undici
  - An HTTP/1.1 client, written from scratch for Node.js
  - https://github.com/Ethan-Arrowood/undici-fetch

    - A WHATWG Fetch implementation based on @nodejs/undici

- Next.js automatically polyfills fetch API on the server-side, but in my book I do explore alternatives... and Undici is by far my favorite one
- Yep. Undici is more reliable, it's well designed and tested, and it has better defaults for serverless environments. 
  - We're already using it inside some places of the @vercel core production infrastructure which gives us the confidence to adopt it more broadly.
  - I could even see it providing the `fetch` global in the default Node.js distribution 
