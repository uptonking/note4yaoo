---
title: page-editor-dev
tags: [editor, text-editor]
created: '2021-10-12T07:07:44.058Z'
modified: '2021-10-12T07:08:36.327Z'
---

# page-editor-dev

# guide
- [中文排版需求-W3C草稿](https://www.w3.org/TR/clreq/)
# [「排版软件」浅析](https://blog.edeity.me/typo.html)
- 离开金山已有两月，在金山两年半的时间里，过得还是比较愉快的，结了婚学了车买了房，也有幸和金山WEB部门一起成长。
  - 希望将自己所学或所感悟的东西，在此记录成一篇小文章，作为技术类别的一次回忆。

- 对于排版（无论是排软软件或浏览器的排版引擎），均可用以下层级来理解：不受限于何种平台，比如文字的多端（PC Windows/Macos、移动 Android/Ios，Web），均采用这种抽象来划分层级。
- 从上到下
  - ui 用户交互
  - render 渲染更新
  - typo 排版
  - data 数据模型

## 数据层

- 数据层级的作用，是将原始的数据（比如Word的Docx，一种特殊的XML；或者排版引擎的HTML、CSS源文件），转化为计算机容易识别的数据结构。
- 大概涉及两方面的内容：一方面为解析，另一方面结构化。
- “解析“大多属于编译原理的内容，词法分析，自下而上语法分析，中间码优化等。（最近突然意识到HTML，因为要兼容各种稀奇古怪的DTD语法，竟是一种上下文有关的语法）。
- ”结构化“就是通常意义的数据结构，
  - 我所知的：比较均衡的有区间树（一种针对索引建立缓存的红黑树），或者是碎片表（压缩存储空间）。
  - 因为上层的业务操作会频繁触发数据的更新和读取，此层最考验计算机功底。

## 排版层

- 排版的作用，就是依照一定的规则，将数据转化为元素。这些元素最基本的特征，就是坐标（x, y）、形状。
- 在我接触的绝大多数情况下，形状都是长方形的（rect(width, height)）。
  - 因为长方形能满足常规的排版要求，而且是规则图形，计算量少。
- 而最基本的排版元素，当属「字体」。字体虽然很常见，但也可以很复杂。
  - （感兴趣可以查看：字体渲染库FreeType）。
  - 不同的产品对字体的理解也存在差异，为了便于理解，我们可以将字体约等于我们前端领域的“盒子”模型。
- rect形状决定了元素的长宽。而元素的坐标，则依赖于规则。
  - 最常见的规则，便是「自左而右，自上而下」的流式布局。
  - 简单而言，就是将元素顺序从左到右依次排列，元素间紧密不重合。
  - 若一行无法放下时，便自上而下另起一行，重新排列。
- 排版规则的多样性，决定了排版的复杂度。
  - 最简单的流式布局，只要稍一改变，就可能带来复杂的变化，比如正常的文字流，遇到图片可以演变为“环绕”的效果，遇到阿拉伯语（从右到左）可以演变为Bidi标准。
- 同样的布局，也可能来源于不同的描述方式，比如CSS中的inline/block、Flex、Grid等。
- 当然，很多时候，元素也会相交，由此衍生出层级的概念（比如css中的z-index）。
- 一般而言，不同层级的元素，占用不同的排版空间，互不影响。
- 在文字等排版软件中，排版是作为最核心的存在。

## 渲染层

- 排版后，我们得到了元素的布局属性，这些属性是数值方式存储的。
  - 将已具备空间属性的元素在用户前端设备展示的过程，便是「渲染」。
- 二维排版的渲染相对3D而言，运算量要少很多。
  - 但两者在优化上也可以是相通的，比如常见的优化方式都可以是：局部/分层渲染（只渲染当前视图的内容，或按照主次异步渲染不同图层），离屏渲染/双缓冲（提前完成下一帧计算，并加入到缓冲池中）。
- Web端的渲染，常见有三种载体，分别为：DOM（浏览器提供最核心的排版接口），SVG（矢量图，在放大缩小方面能保持不失真），Canvas（位图，基于像素点）。
- 排版 + 渲染的执行速度，基本上就决定了“帧率”的高低，帧率用户体验上发挥着至关重要的作用。
- 选择DOM，在某种程度可能要受限于已有的排版/渲染规则，但在受限的同时往往将最复杂的问题抛给浏览器，从而减少功能迭代的开发工作量，主流的开源富文本编辑器往往会采用这种方式（比如Prosmirror、Slate等）。
- 而选择Svg或Canvas，则意味着你需要投入人力物力，但也获得了无限可能，商用的排版软件往往采用这种方式（比如金山文档，谷歌文档等）。
- 值得一提，选择Svg还是Canvas，取决于渲染的元素和空间的多少。

## 用户交互层

- 「用户交互」往往是前端工程师和产品们的主战场。
- 从产品角度而言，用户的年轻化，对“兼容”更宽容，而对“体验”更敏感。
- 常见的写作场景，“体验”的高低存在一个重要的因子：不中断用户输入，又称为沉浸式，依次诞生了Markdown（尽可能少地关注排版，使双手保持在键盘上的格式），以及Notion（尽可能少地在软件中切换，文档不仅局限于排版，而是包容万物的产品）。

- 在用户交互层次上，要分享一个关键的逻辑：「点击测试」。这是一个建立视图到用户的连接通道。
  - 点击测试，可以理解为一个方法：传入（x，y）坐标，返回当前坐标的元素数据。
  - 某些观点认为，要实现自定义的选区和光标，依赖于自排自绘，这个观点是片面的，
  - 自定义光标和选区，依赖于能否有效且精准地“拿到”排版信息，而点击测试正是其中的关键。
  - 实践也证明（金山文档），基于DOM的编辑器也是可以相对精准得到元素数据的排版信息而实现自定义光标和选区的。
- 学会了从更高的层级看待事物，而不局促于局部代码，无论对理解浏览器，还是排版软件（或富文本编辑器），都会拥有一个更全面的认知。
# [WEB文字性能优化简述](https://blog.edeity.me/optimize_docs.html)
- 方向
  - 首屏加载速度
  - 高频操作优化，如输入

- 文字渲染的一般流程
  1. 文字排版：输入后，计算布局排版结果（类似于浏览器的重排）
  2. 排版渲染：得到排版结果，文档前端绘制（类似于浏览器的重绘）
  3. 视图更新：GCP变化触发一系列React组件更新

- 测量工具
  - browser devtools
  - react devtools

## 首屏优化

- 按业务分阶段加载组件：
  - 首屏渲染阶段（KPI生命线）
  - 首屏渲染后（加载一些必要的组件，避免断网影响）
  - 其他辅助功能（用到时才加载）。

- 网络层面优化：
  - preload服务端渲染
  - 提取公共库以及业务核心库（eg：React，polyfill），并移除某些polyfill，减少约10%代码量
  - 语法层面采用更规范的ES6 module
    - Babel默认的Commonjs会引入副作用导致webpack无法Tree Shake
    - 减少约7%代码量
  - 缓存：
    - cdn缓存（更新频繁时，命中率周期变化）
    - pwa缓存（这个作用不好评估，会加大init的时间），【后续，已移除PWA，中国缺少PWA生存土壤】
    - 入口文件prefetch文件
    - 组件相互唤起（未参与，不知优化效果）
  - 请求方式：提前加载，串行转并行
    - webpack code split后不注意会导致串行
    - 首次加载，网速较慢时，约提高100ms（未来可考察server push）

## 高频操作优化

- 目标：更新周期耗时，期望小于16ms（60FPS-流畅），不高于32ms（30FPS-平稳）。

- 方法
  - 对实时函数调用，进行性能优化。
  - 对非实时函数调用，进行限流防抖。

- 限制操作频率（最简单粗暴且有效）
- 限制更新频率：
  - 组件更新异步：requestAnimate或requestIdleCallback中（eg：SelectionChanged）
  - 减少setState调用次数（触发React diff，会占用1~2ms的时间）
  - 缓存高频属性（如clientWidth、scrollTop等）（throttle自带缓存机制）
- 用ES5的接口替代部分JS实现
  - Object.assign取代copy
  - 避免过频使用RegExp等（第一次向Chromium提bug）
  - 高频方法避免使用析构...args（polyfill后会转变成数组的slice、concat，耗时严重）
- 渲染方面，svg较canvas，在放大缩小操作上有明显的性能优势
  - svg结构松散时，可合并图层（离屏渲染、DocumentFragment）
- 更优的数据结构，如区间树等
  - 数据巨大，遍历树时，仍是耗时操作，同样需要缓存高频属性
# [2020 普通人，平常事](https://blog.edeity.me/2020_sim_and_normal.html)
- 有感于为高频属性访问对象比较集中（一般是正文的滚动高度啊，可视区高度宽度之类），存在部分场景缓存更新不及时的情况
  - 所以决定中途换轮子，将目前的原生滚动切换成模拟滚动，属性由代码维护提供，减少读取原生属性消耗。
  - 本以为手写个模拟滚动很简单，一两周搞完，结果因为目前排版是阻塞的，改造没准要花几个月还存在高风险，只好另辟蹊径，陷入了漫长的优化中

- 九月份插进来一个需求，全面适配Ipad
  - 回过头，感觉忙碌了一个月，也只是知道了诸如尽可能避免hover，避免异步focus，要尽可能抹平touch/mouse差异这种小技巧。

- 因为新部门基于div的contenteditable来做编辑器（用了开源框架），所以好多奇形怪状的BUG因涉及原生问题无法修复，需要额外的层来抹平正文交互上的浏览器差异。
  - 折腾了一个星期，才有了初步的方案：新建拦截层拦截点击输入事件，在确保兼容原框架的前提下，实现自定义的光标/选区。也还算通用的解决方案吧。
# [如何获取Input中光标的位置？](https://lastnigtic.cn/input-caret/)
- 需求：测试提出气泡要能跟随光标的位置移动

- 旧方案：input上波浪线由覆盖在input上面的span显示，span 绑定点击事件，显示对应的气泡。
- 问题：
  - 点击span后光标在 input 中的位置需要额外计算，容易出错
  - 无法拖动选中

- 新方案
  - 波浪线方案保持一致，但不覆盖 input，只作为样式存在，不关心事件
  - 使用 input 特有的属性 selectionStart，兼容性表现也很好
  - 复用波浪线的位置数据，代替通过 span 的点击事件确定位置

- 确定了新方案之后，主要的问题就变成了解决如何获取光标所在的位置。
- 想要获取光标相对于屏幕的位置信息，大概可以分三步走：
  - input 相对于屏幕的位置
  - 光标相对于 input 的位置
  - 累加位置信息的得出光标相对屏幕的位置
- 难点主要在第二步，如何获取光标相对于屏幕的位置。
  - 获取光标位置 ≈ 获取光标后面的元素的位置信息
  - mock 出一个于 input 一模一样 DOM
  - 根据 selectionStart 的信息把 input 文字分为两部分
  - 获取后一部分的元素的位置信息即为光标相对于input的位置
- 着手实现
  - 为了方便可以直接获取 ​getComputedStyle().cssText​，作为 mock input 的 style，当然最好是获取和位置相关的 css 就好。
  - mock 两个 dom，储存 input 的文字信息。
  - 根据 selectionStart 把 input 截断为两段
  - 最后就可以通过 offset 来获取位置信息

- 对于这种情况，1，2 的位置 selectionStart 是一样的，按照我们上面的方法，我们只能获取到 2 的位置信息。这也是目前没有解决的问题之一（也是 ≈ 的原因）。
