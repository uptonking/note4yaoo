---
title: lib-editor-milkdown-docs
tags: [docs, editor, markdown, milkdown]
created: 2021-07-11T15:07:37.949Z
modified: 2021-07-11T15:08:34.195Z
---

# lib-editor-milkdown-docs

> A plugin-driven WYSIWYG markdown Editor, inspired by Typora, built on top of prosemirror and remark.

# guide

# overview
- milkdown /940Star/MIT/202107/ts
  - https://github.com/Saul-Mirone/milkdown
  - https://saul-mirone.github.io/milkdown/
  - https://saul-mirone.github.io/milkdown/#/online-demo
  - 依赖prosemirror、remark、prism、katex，但不依赖prosemirror-markdown、react
  - 不同于其他prosemirror项目，可配置支持的markdown特性
  - ⚠️️breaking: @milkdown/core@4.4.0(date202107) migrate from markdown-it to remark

- Milkdown treats every features as plugins.
  - With this pattern, developers can choose what they need in an editor instead of bundle all features even they won't need.
  - Developers can extends the plugin to satisfy their habit such as define a vim keymap plugin.
- plugins in prosemirror and remark community can be easily reused to build a Milkdown plugin.
- Themes and plugins for Milkdown can be shared and installed using npm packages.

- milkdown is made up by two parts:
  - A tiny core which provide markdown parser, serializer and kinds of plugin loader.
  - Lots of plugins provide syntax, commands and components.
- With this pattern you can enable or disable any custom syntax you like, such as table, latex and slash commands.

- Milkdown is headless, there is no style provided by default.
  - Option 1: Style the plain HTML with `.milkdown .editor yourTag` scope
  - Option 2: Add custom class name with `configure()` method

## plugins

- all features in milkdown are supported by plugin.

- Node and Mark are two special atoms that used to define prosemirror Node and Mark.

- Parser is used to transform from markdown string to UI elements.
  - 解析流程：md str > mdast > PM Node > PM EditorView > dom
  - markdown string will be given to `remark-parse` to compile into AST
  - remark AST will be traversed by milkdown parser. 
  - The milkdown parser is generated by the parser property of nodes and marks and generate a prosemirror node tree as the result.
  - The prosemirror node will rendered by prosemirror and generate the UI elements.

- The parser state is used to generate the prosemirror node, it provides several useful methods to make the transformation pretty simple.
  - `openNode` method will open a node, and all nodes created after this method will be set as the children of the node until a `closeNode` been called.
  - For nodes have `children`, your `runner` should just take care of the node itself and let other runners to handle the children.

- Serializer is used to transform from UI elements to markdown string.
  - 序列化流程: PM Node > mdast > md str
  - For the current UI status, there will be a prosemirror node tree to represent it.
  - The prosemirror node tree will be traversed by milkdown serializer. The milkdown serializer is generated by the serializer property of nodes and marks and generate a remark AST as the result.
  - The remark AST will by transformed into markdown string through `remark-stringify`.

- The serializer state is used to generate the remark AST, it provides several useful methods to make the transformation pretty simple.
  - `openNode` method will open a node, and all nodes created after this method will be set as the children of the node until a `closeNode` been called.

- **Example: Custom Syntax**
- Generally, if we want to add a custom syntax, there are 5 things need to be done:
  - Add a remark plugin to make sure the syntax can be parsed and serialized correctly.
  - Define the prosemirror schema for your custom node.
  - Write a parser specification to transform the remark AST into prosemirror node.
  - Write a serializer specification to transform the prosemirror node into remark AST.
  - Write prosemirror input rules to make sure user input can be handled correctly.
- Example: we will add a custom iframe syntax to insert iframe as node in milkdown.

## architecture

- Milkdown core is composed mainly by three parts:
  - Markdown Parser
  - Markdown Serializer
  - Prosemirror

- Markdown Parser
  - **transform a markdown string into a prosemirror node tree**
  - It is mainly used by transforming the default value, and can be used in features like paste markdown strings.
  - The parser will parse the markdown strings into ast by remark, 
  and transform the ast into the prosemirror node.

- Markdown Serializer
  - **transform a prosemirror node into a markdown string**
  - It is mainly used by listeners, and can be used in features like export to file.
  - The serializer will parse the prosemirror node tree and transform it into markdown ast, 
  then the ast can be serialized into markdown string.

- Prosemirror is used for **render the editor**.
  - When users interact with the editor, they actually interact with the prosemirror view instance.

- So basically, a milkdown editor works following these steps:
  1. Default value is parsed by parser, generates a node.
  2. Node generated by step 1 will be used to create a prosemirror instance.
  3. When changes are triggered, the listeners will be called and developers can use serializer to get markdown string.

- In the world of milkdown, everything are Atoms.
  - The only thing the core part of milkdown do is execute these atoms one by one.
  - The order of the atoms loaded matters.
  - We have defined a `LoadState` enum so Atoms can be loaded after the pointed `loadState`.
  - You can access certain properties in context during the given load state.

- Generally speaking, there is no need for you to set the load state of an atom, we have provide some utilities for users to create certain types of atoms.
- `Idle` state means the editor is preparing, nothing has been loaded.
  - props available: loadState, remark, nodes, marks
- `LoadSchema` state means the editor is ready to generate the schema.
  - props available: all props in `Idle` state
- `SchemaReady` state means the editor has generated the schema.
  - props available: all props in `LoadSchema`; schema, parser, serializer, keymap, inputRules, nodeViews
- `LoadPlugin` state means the editor is ready to load prosemirror plugin.
  - props available: all props in `SchemaReady`; prosemirrorPlugins
- `Complete` state means the editor has fully loaded.
  - props available: all props in `LoadPlugin`; editorView
